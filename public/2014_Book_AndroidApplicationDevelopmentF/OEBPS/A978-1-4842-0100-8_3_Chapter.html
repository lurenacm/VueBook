<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><title>Android Application Development Processes and Tool Chains for Intel® Architecture</title><link href="springer_epub.css" type="text/css" rel="styleSheet"/></head><body><div class="ChapterContextInformation"><div class="ContextInformation" id="Chap3"><div class="ChapterCopyright">© Ryan Cohen 2014</div><span class="ContextInformationAuthorEditorNames"><span class="Author"><span class="AuthorName">Ryan Cohen</span> and </span><span class="Author"><span class="AuthorName">Tao Wang</span></span></span><span class="ContextInformationBookTitles"><span class="BookTitle" xml:lang="en">Android Application Development for the Intel<sup>®</sup> Platform</span></span><span class="ChapterDOI">10.1007/978-1-4842-0100-8_3</span></div></div><!--Begin Abstract--><div class="MainTitleSection"><h1 class="ChapterTitle" xml:lang="en">3. Android Application Development Processes and Tool Chains for Intel<sup>®</sup> Architecture</h1></div><div class="AuthorGroup"><div class="AuthorNames"><span class="Author"><span class="AuthorName">Ryan Cohen</span><sup>1 <span class="ContactIcon"/></sup> and </span><span class="Author"><span class="AuthorName">Tao Wang</span><sup>1 <span class="ContactIcon"/></sup></span></div><div class="Affiliations"><div class="Affiliation" id="Aff1"><span class="AffiliationNumber">(1)</span><div class="AffiliationText">OR, USA</div></div><div class="ClearBoth"> </div></div></div><!--End Abstract--><div class="Fulltext"><div id="Par2" class="Para">This chapter introduces Android† application development on Intel hardware platforms. Developing Android system applications requires some special development, debugging, and performance analysis tools, and the development environment and object formats are different from those of general-purpose desktop computers. Before developing Android applications, we need to learn about the development process of Android system applications.</div><div id="Par3" class="Para">Android provides a whole set of tool chains (toolsets) for application development. Early versions of the Android OS supported ARM hardware platforms and started supporting Intel<sup>®</sup> Atom<sup>™</sup> hardware platforms from Android 2.3 (Gingerbread). To support application development on Intel Atom architecture, Intel has added important plug-ins, libraries, and other auxiliary modules to work in conjunction with Android tool chains. In addition, to help developers to get the performance advantages of Intel hardware, Intel has made available development tools such as compilers and Intel<sup>®</sup> Graphic Performance Analyzer.</div><div id="Par4" class="Para">This chapter describes the general processes and methods for Android application development on Intel Atom platforms. The methods to achieve optimized performance and low energy consumption using special Intel tools will be introduced in subsequent chapters.</div><div id="Sec1" class="Section1 RenderAsSection1"><h2 class="Heading">Android Application Development</h2><div id="Par5" class="Para">The following sections describe the development environment, development process, debugging, and simulation of Android systems.</div><div id="Sec2" class="Section2 RenderAsSection2"><h3 class="Heading">Development Environment of Android Applications</h3><div id="Par6" class="Para">As we mentioned earlier, software development for general-purpose computers is always achieved through native compilation or development. In general, embedded systems are not compatible with the local development environment and so software development is usually done with cross-development.</div><div id="Sec3" class="Section3 RenderAsSection3"><h4 class="Heading">Cross-Development</h4><div id="Par7" class="Para">The typical cross-development configuration is shown in Figure <span class="InternalRef"><a href="#Fig1">3-1</a></span>. The cross-development environment is built on the development, or host, machine. Usually the host machine is a general-purpose computer such as a PC. The corresponding embedded system is called the target machine. Target machines can be any of the numerous kinds of embedded devices such as mobile phones, tablets, and so on. They may also be special evaluation boards or software-based emulators for development provided by embedded system manufacturers. During development, cross-compilation, assembly, and linking tools on the host machine are used to produce binary code that is executable on the target machine; then the executable files are downloaded and run on the target machine. The cross-development method is not only required for compilation but also for debugging. <div class="Figure" id="Fig1"><div class="MediaObject" id="MO1"><img src="A978-1-4842-0100-8_3_Fig1_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig1_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-1.</span><div class="SimplePara">Cross-development configuration of embedded systems</div></div></div></div>
              </div><div id="Par8" class="Para">The main reason why cross-development was adopted for embedded systems is that native compilation usually cannot be done effectively on the target machine. First, the hardware of the target machine is often unavailable or unstable during the development process. Second, there is a lack of complete native compilation tools on the target machine platform. Third, the performance of the target machine is insufficient, resulting in slow compilation. Software compilation on embedded systems is more time consuming than on desktop computers because it requires not only compilation of applications but also compilation of library dependencies and OS kernels. For example, compiling a Linux† kernel on an Intel<sup>®</sup> Pentium<sup>®</sup> 4 processor-based PC takes more than 10 minutes. The main hardware factors determining the compiling speed include CPU speed, memory capacity, and file system I/O speed. On these factors, embedded systems usually perform worse than PCs. This results in low efficiency of native compilation on target machines. The cross-development method is always adopted for embedded systems, such as cross-compilation (including cross-linking) and cross-debugging.</div><div id="Par9" class="Para">Because of the differences between the host machine and the target machine in their configurations, functions, system structure, and operating environments, they are usually connected via serial port, parallel port, USB, or Ethernet connection cables. Toolsets, including encoder, compiler, connector, debugging tool, and software configuration management tool, are installed on the host machine.</div><div id="Par10" class="Para">Generally, the host machine and the target machine are different in the following aspects:
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par11" class="Para">Different structure: usually, the host machine is an Intel architecture system while the target machine might be Intel or non-Intel architecture system structure such as ARM or MIPS.</div></li><li><div id="Par12" class="Para">Different processing capacities: usually, the processing speed and storage capacity of the host machine are better than those of the target machine.</div></li><li><div id="Par13" class="Para">Different operating systems: usually, a general OS runs on the host machine while an Android OS runs on the target machine.</div></li><li><div id="Par14" class="Para">Different output methods: compared with the host machine, the input and output functions of the target machine are less capable.</div></li></ul></div>
              </div><div id="Par15" class="Para">For some Android systems, these characteristics may not exist or are insignificant. Take the development of an Intel Atom system for example. The host machine and the target machine use the same system Intel architecture structure. Of course, the instruction sets might be different. For example, the host machine (such as the Intel<sup>®</sup> Core<sup>™</sup> 2 Duo processor) might be compatible with SSE4, while the Intel Atom processor only supports SSE3 .We should consider the instruction set for the target machine during compilation. Considering the limited resources of most Intel Atom systems, we recommend the cross-development method.</div></div><div id="Sec4" class="Section3 RenderAsSection3"><h4 class="Heading">Programming Languages</h4><div id="Par16" class="Para">During the past four decades, dozens of programming languages have been developed for general-purpose computer applications. From FORTRAN, C/C++, ADA, and Java† to C#NET. Many factors determine a programming language’s suitability. Each has its own characteristics, and comprehensive comparisons are impossible. Each language’s performance depends on the execution environment. Considering multiple factors and actual development status, the common languages for Android systems include C/C++, Java, and Python†, and occasionally assembly language is used. A combination of languages is needed for programming a sophisticated Android system. The common programming languages are shown in Table <span class="InternalRef"><a href="#Tab1">3-1</a></span>.<div id="Tab1" class="Table"><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Table 3-1.</span><div class="SimplePara">Commonly Selected Programming Languages</div></div></div><table border="1"><colgroup><col/><col/></colgroup><thead><tr class="header"><th><div class="SimplePara">Level</div></th><th><div class="SimplePara">Common Programming Languages</div></th></tr></thead><tbody><tr class="noclass"><td><div class="SimplePara">Application software</div></td><td><div class="SimplePara">C/C++, Java, .NET, script, Python</div></td></tr><tr class="noclass"><td><div class="SimplePara">OS level</div></td><td><div class="SimplePara">C/C++, Assembly</div></td></tr><tr class="noclass"><td><div class="SimplePara">Driver program level</div></td><td><div class="SimplePara">C/C++, Assembly</div></td></tr><tr class="noclass"><td><div class="SimplePara">Boot code, Hardware Abstract Layer (HAL)</div></td><td><div class="SimplePara">Assembly, C/C++</div></td></tr></tbody></table></div>
              </div><div id="Par17" class="Para">Java, launched by Sun Microsystems in May 1995, is a cross-platform object-oriented programming language and includes the Java programming language and Java platforms (JavaSe, JavaEE, JavaME). Java’s style is very similar to that of C and C++. It is a pure object-oriented programming language that has inherited the core contents of the object-oriented C++ and abandoned the pointer (replaced by reference), operator overloading, and multiple inheritance (replaced by interface) in the C++ language, which caused frequent errors. The added Garbage Collector is used for collecting memory occupied by unreferenced objects so the programmer does not need to worry about memory management. In the Java 1.5 version, Sun added other language features such as generic programming, type-safe enum class, variable-length augment, and autoboxing/auto-unboxing.</div><div id="Par18" class="Para">Java is different from ordinary compilation and execution computer languages in that it is an interpretive computer language. The Java compiler produces binary byte code instead of machine code, which can be executed directly and locally. Compiled Java programs are interpreted into directly executable machine code via Java virtual machine (JVM). The JVM can interpret execution byte code on different platforms to realize the cross-platform feature of “one-time compilation for all executions.” However, it takes some time to interpret byte code, which will to some degree reduce the running efficiency of Java programs. To reduce this burden, Google introduced Android Run Time (ART) in 2014 as a Dalvik version 2, which first became available as a preview feature in KitKat (Android 4.4). Future 64-bit Android will be based on ART. In general, Java is a simple, object-oriented, distributed, interpretive, and stalwart. It is an implantable, high-performance, multi-threaded and dynamic programming language. Considering various advantages of Java, it is the first choice for Android application development.</div><div id="Par19" class="Para">Having chosen a language, you may not necessarily use all of its functions. Although we have selected Java as the development tool for Android, the development process for Android systems is different from traditional (desktop) Java SDK. The Android SDK uses most of the Java SDK, but has abandoned some portions. For example, for the interface, the java.awt package is only referenced by java.awt.font. If a Java game is migrated to the Android platform, it might need to be ported.</div><div id="Par20" class="Para">We have mentioned that Java is a cross-platform interpretive computer language. This feature has enabled the high migration capability regardless of platform, but it also has some drawbacks, one of which is that the developer cannot use platform- or architecture-related features or potential. But this can be achieved by machine-related target code by compiling C/C++ and assembly languages. This is more obvious during performance optimization. To use the features of the machine hardware and tap into their performance potential, we usually need to use C/C++ and assembly languages for writing optimized applications. Although such code accounts for a small proportion of all code, the programming complexity is much higher than Java. Therefore, such code is only used in some rare cases. We’ll see that Android application development has adopted a mixed programming mode based mainly on improved Java and supported by C and assembly languages.</div><div id="Par21" class="Para">We’re going to discuss this programming method in two parts. For developing general functions of Android applications, we are going to use Java. But for performance optimization, we’re going to use a mixed-language programming approach.</div></div></div><div id="Sec5" class="Section2 RenderAsSection2"><h3 class="Heading">The Android Application Development Process</h3><div id="Par22" class="Para">Generally speaking, developing Android software requires the same steps as general-purpose software: designing, encoding, compiling, linking, packaging, deploying, debugging, and optimizing. For some Android systems, testing and verification steps are also required. In terms of process, it can be divided into five stages: encoding, construction, deployment, debugging, and tuning. The typical development process is shown in Figure <span class="InternalRef"><a href="#Fig2">3-2</a></span>.<div class="Figure" id="Fig2"><div class="MediaObject" id="MO2"><img src="A978-1-4842-0100-8_3_Fig2_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig2_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-2.</span><div class="SimplePara">Development process for Android software</div></div></div></div>
            </div><div id="Sec6" class="Section3 RenderAsSection3"><h4 class="Heading">Encoding</h4><div id="Par23" class="Para">Encoding is the first step in the software development process. Software source code can be written using various editors. During Android development, this work is mainly editing .java code and .xml source files.</div></div><div id="Sec7" class="Section3 RenderAsSection3"><h4 class="Heading">Construction</h4><div id="Par24" class="Para">The task during the construction stage is to convert code into executable programs on Android hardware. This stage includes sub-steps such as compiling, linking, and packaging as shown in Figure <span class="InternalRef"><a href="#Fig3">3-3</a></span>. <div class="Figure" id="Fig3"><div class="MediaObject" id="MO3"><img src="A978-1-4842-0100-8_3_Fig3_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig3_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-3.</span><div class="SimplePara">Software construction stage</div></div></div></div>
              </div><div id="Par25" class="Para">The first step of construction is the build, which means to translate all source code files into target files. Some target files are machine-related such as C/C++ target files that correspond to the execution instructions of the machine. But some are not specific to the machine, such as Java target source code that is not machine-executable instructions. During Android application development, these files usually have the suffix <span class="EmphasisTypeItalic">.class</span>. On Android, .classes are translated to .dex files.</div><div id="Par26" class="Para">The second step is packaging. The purpose of packaging is to combine and install all target files and affiliated files into one folder on the target machine. As for Android, .dex files and resource files are all packaged into an .apk file that can be stored outside the target machine. The packaging operation is usually done with special packaging tools.</div></div><div id="Sec8" class="Section3 RenderAsSection3"><h4 class="Heading">Deployment</h4><div id="Par27" class="Para">Deployment, the last stage of software development, is where the installation package is copied from the host machine, decompressed, and installed into the memory of the Android device.</div><div id="Par28" class="Para">Android has adopted USB cable-based ISP deployment. As shown in Figure <span class="InternalRef"><a href="#Fig4">3-4</a></span>, the host machine is connected to the target machine via USB cable. The Android OS runs on the target machine while the Windows† or Linux OS runs on the host machine. The file packages generated (.apk) are copied to one directory of the file system in the target machine before being decompressed and installed to finish deployment. The process can be done using command line terminals or the DDMS inside Eclipse.<div class="Figure" id="Fig4"><div class="MediaObject" id="MO4"><img src="A978-1-4842-0100-8_3_Fig4_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig4_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-4.</span><div class="SimplePara">Android application deployment</div></div></div></div>
              </div><div id="Par29" class="Para">Under the online programming model, the copying direction of the files between the host machine and the target machine is different. And different terminologies are used for file copying. For example, download/upload is called push/pull in Android. <span class="EmphasisTypeItalic">Push</span> means to copy files from the host machine to the target machine, while <span class="EmphasisTypeItalic">pull</span> means copy files from the target machine to the host machine.</div></div><div id="Sec9" class="Section3 RenderAsSection3"><h4 class="Heading">Debugging and Optimizing Stage</h4><div id="Par30" class="Para">This stage is mainly debugging and optimizing operations on software.</div><div id="Par31" class="Para">Even the most experienced software engineers cannot totally avoid mistakes in their programs. Mastering debugging techniques is critical for software development. Debugging Android software code is not very efficient because even if you only need to change one line of code, you still need to go through all the build, packaging, and deployment procedures. PC users might be okay with one crash per day. But just imagine the severe consequences if a bug exists in the final Android system product on ATMs, medical operation systems, or satellites.</div><div id="Par32" class="Para">There are many debugging technologies and techniques for Android software discussed in subsequent sections. Many of the methods are rarely used in general-purpose computer software.</div><div id="Par33" class="Para">The minimum target for a software product is to ensure its normal running. But this target is not good enough for Android software, which is resource-constrained and has more stringent space and performance requirements than desktop systems. To satisfy these requirements, Android software has to ensure normal running in a performance-optimized way. These goals might be contradictory and developers can hardly realize all of them. So they make compromises usually highlighting the performance requirement.</div><div id="Par34" class="Para">Improving the performance of an application program is a time-consuming process. It is usually not obvious which functions are consuming most of the execution time. So we need to use specialized tools to analyze the code to accurately understand the performance bottlenecks and advise us on improvements. This process is usually called code profiling, and the tool used is called a <span class="EmphasisTypeItalic">profiler</span> or <span class="EmphasisTypeItalic">performance analyzer</span>.</div><div id="Par35" class="Para">The principle of using a profiler for improving performance is to optimize the frequently called portions of the software. For example, if 50 percent of the time is spent on string functions and we optimize such functions by 10 percent, then we can reduce the execution time of the software by about 5 percent. By using a profiler you can accurately measure the various portions of time spent during the execution process to understand which areas can be optimized. Some profilers can bring about improvement suggestions specific to the type of processor. For example, the Intel<sup>®</sup> Vtune<sup>™</sup> Amplifier identifies hotspots in the code that can be further optimized to improve overall performance.</div></div></div><div id="Sec10" class="Section2 RenderAsSection2"><h3 class="Heading">Debugging and Simulation of Android Systems</h3><div id="Par36" class="Para">Debugging Android software has some special challenges, so some methods and devices have been developed to assist developers with the debugging procedure. The most common debugging methods include those described in the following sections.</div><div id="Sec11" class="Section3 RenderAsSection3"><h4 class="Heading">System Simulator</h4><div id="Par37" class="Para">Early system simulators were realized with instruction set emulators, that is, the technology of simulating a system architecture using software. In other words, software is used to interpret machine codes to simulate a certain processor. Modern system simulators include analog peripherals except CPU simulation. The analog peripherals are used to achieve system simulation results. Some books call the simulator a virtual machine or emulator.</div><div id="Par38" class="Para">Instruction set emulation includes homogenous emulation and heterogeneous emulation. Homogenous emulation means using software on one processor to emulate a virtualized machine that has the same architecture. At present, the common Microsoft Virtual PC or VMware† emulates the execution of processors based on Intel architecture, making it a type of homogenous emulation. Heterogeneous emulation means emulating the execution of another processor on one processor. Most of the instruction set emulators are types of heterogeneous emulation. For example, Device Emulator emulates the execution of ARM processors on Intel architecture processors. Some common system simulators are shown in Table <span class="InternalRef"><a href="#Tab2">3-2</a></span>. <div id="Tab2" class="Table"><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Table 3-2.</span><div class="SimplePara">Common System Simulators</div></div></div><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr class="header"><th><div class="SimplePara">Name of Emulator</div></th><th><div class="SimplePara">Simulated Target Platform</div></th><th><div class="SimplePara">Remarks</div></th></tr></thead><tbody><tr class="noclass"><td><div class="SimplePara">Microsoft Virtual PC/Virtual Server</div></td><td><div class="SimplePara">Intel<sup>®</sup> architecture</div></td><td> </td></tr><tr class="noclass"><td><div class="SimplePara">VMware</div></td><td><div class="SimplePara">Intel architecture</div></td><td><div class="SimplePara">Compatible with Windows, Mac†, Linux</div></td></tr><tr class="noclass"><td><div class="SimplePara">Bochs</div></td><td><div class="SimplePara">Intel architecture</div></td><td><div class="SimplePara">Open source projects</div></td></tr><tr class="noclass"><td><div class="SimplePara">Device Emulator</div></td><td><div class="SimplePara">ARM</div></td><td><div class="SimplePara">Simulation of SMDK2410 development board</div></td></tr><tr class="noclass"><td><div class="SimplePara">SkyEye</div></td><td><div class="SimplePara">ARM</div></td><td><div class="SimplePara">Made in China</div></td></tr><tr class="noclass"><td><div class="SimplePara">VirtualBox Advance</div></td><td><div class="SimplePara">ARM</div></td><td><div class="SimplePara">Simulating Nintendo GBA gamer</div></td></tr><tr class="noclass"><td><div class="SimplePara">Oracle VM Virtualbox</div></td><td><div class="SimplePara">X86 and AMD64/Intel64 Virtualization</div></td><td><div class="SimplePara">GPL license, and freely available</div></td></tr></tbody></table></div>
              </div><div id="Par39" class="Para">When debugging programs on Android systems, the host machine (usually the PC) runs the system simulator and the software of the target machine is run in the system simulator, so no extra hardware is required. The host machine and the target machine are realized on the same machine, which is known as “two uses on one machine.” Now remember the cross-development environment mentioned previously? We said the target machine is not necessarily a real device because it might be a software-based emulator. The emulator replaces the actual target machine during cross-development. Emulators not only save overhead on hardware but make debugging more convenient.</div><div id="Par40" class="Para">Android development tools bundles Android Virtual Device, a manager that is used to create ARM and x86 emulators. Emulators mimic the hardware and software configuration of a target device. Figure <span class="InternalRef"><a href="#Fig5">3-5</a></span> shows a screenshot of an AVD running in Windows. <div class="Figure" id="Fig5"><div class="MediaObject" id="MO5"><img src="A978-1-4842-0100-8_3_Fig5_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig5_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-5.</span><div class="SimplePara">AVD (Android Virtual Device) interface</div></div></div></div>
              </div><div id="Par41" class="Para">The Android emulator is also called <span class="EmphasisTypeItalic">goldfish</span>. Each AVD simulates a set of mobile devices that run the Android platform, which includes the kernel, system image, and data partitioning as well as the SD card, user data, and the display. Android emulators are based on Qemu, which is a popular open source virtualizer project. The source code for Android emulators is under the external/qemu directory.</div><div id="Par42" class="Para">AVD simulates the common components of the target machine such as the CPU, screen, keyboard, audio output, camera, and also sensors such as GPS, touch, and gravity acceleration. For example, AVDs with Intel architecture include Intel x86 system images corresponding to each API level. Of course compared to the real device, an AVD has certain shortcomings, which include:
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par43" class="Para">Inability to place or accept actual calls; but it can simulate phone calls (incoming and outgoing) via control station</div></li><li><div id="Par44" class="Para">No USB connection</div></li><li><div id="Par45" class="Para">Inability to capture digital photos or videos</div></li><li><div id="Par46" class="Para">Inability to capture audio input, but does support output (replay)</div></li><li><div id="Par47" class="Para">Lack of support for extended earphones</div></li><li><div id="Par48" class="Para">Inability to determine the battery level or charging status of AC power</div></li><li><div id="Par49" class="Para">Inability to determine whether an SD card has been inserted or removed</div></li><li><div id="Par50" class="Para">Lack of support for Bluetooth†</div></li></ul></div>
              </div><div id="Par51" class="Para">In addition, AVD can simulate USB and network connections between the host machine and the target machine. AVD uses the host machine as the default gateway and NAT (address translator) to connect to the network. In other words, if you can access the Internet on the host machine, you can also do so on the AVD-simulated target machine.</div></div><div id="Sec12" class="Section3 RenderAsSection3"><h4 class="Heading">Other Debugging Tools</h4><div id="Par52" class="Para">Android systems have other debugging tools besides system emulators. Although these tools are not used in Android, you should have a basic understanding of them to get a complete picture.</div></div><div id="Sec13" class="Section3 RenderAsSection3"><h4 class="Heading">Cross-Debugging</h4><div id="Par53" class="Para">When the OS supports cross-debugging Android applications, you should try to use this method. Cross-debugging is similar to cross-compilation: the program being debugged runs on the target machine while the display, monitor, and control of debugging are done on the host machine.</div><div id="Par54" class="Para">Cross-debugging can only be performed in the online mode. The host machine needs to be connected to the target machine by USB cable, network, or JTAG-ICE. A debugging server is usually run on the target machine and is called a <span class="EmphasisTypeItalic">stub</span> in the GNU tool chain. The front end running the debugging procedure on the host machine is actually the client. The front end interacts with the developer who makes requests to debugging server. The debugging server receives the commands from the front end, controls application execution, and sends the results to the front end for display, as illustrated in Figure <span class="InternalRef"><a href="#Fig6">3-6</a></span>. <div class="Figure" id="Fig6"><div class="MediaObject" id="MO6"><img src="A978-1-4842-0100-8_3_Fig6_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig6_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-6.</span><div class="SimplePara">Software environment for cross-debugging</div></div></div></div>
              </div><div id="Par55" class="Para">For example, if you set a breakpoint at the front end to observe the values of a variable, the debugging server receives the breakpoint setup request and inserts an interruption at corresponding place in the program. When the application reaches the breakpoint, the debugging server takes over control, suspends the application, and sends back the values of the corresponding variable to the front end, which then displays the value.</div><div id="Par56" class="Para">Many development tools support cross-debugging, such as, for example, GNU debugger. Android Debug Bridge (adb), a common debugging tool, also supports cross-debugging. The adb debugger is based on the client/server model. It works on the principle that the local working platform serves as the debugging client while the machine on which remote applications are installed serves the role of the debugging server. When using adb, the debugging process of the remote applications (on the target machine) may be different from local debugging. Adb manages the device, emulates status, and carries out the following operations: <div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par57" class="Para">Fast code updating in the device and emulators, such as applications or Android system updates</div></li><li><div id="Par58" class="Para">Running shell commands on the device</div></li><li><div id="Par59" class="Para">Managing predetermined ports of the devices or emulators</div></li><li><div id="Par60" class="Para">Copying or pasting files on the devices or emulators</div></li></ul></div>
              </div><div id="Par61" class="Para">Some common operations of adb include the following:</div><div id="Sec14" class="Section4 RenderAsSection4"><h5 class="Heading">adb shell</h5><div id="Par62" class="Para">This command allows you to enter the Linux shell environment of the device or emulator where you can execute many Linux commands. If you want to execute just one shell command, you can enter:</div></div><div id="Sec15" class="Section4 RenderAsSection4"><h5 class="Heading">adb shell[command]</h5><div id="Par63" class="Para">For <span class="EmphasisFontCategoryNonProportional">[command]</span>, enter the particular command you want to execute, for example: <span class="EmphasisFontCategoryNonProportional">adb shell dmesg</span>, which outputs the debugging information of the kernel. Note: the Linux shell for Android adb has been simplified, so it is not compatible with many of the common Linux commands. We’re going to discuss the command line in the subsequent sections.</div><div id="Par64" class="Para">Adb can be run independently in command line form or integrated as a plug-in into your favorite IDE (integrated development environment) such as Eclipse†. Figure <span class="InternalRef"><a href="#Fig7">3-7</a></span> shows a screenshot of debugging an Android application in Eclipse. Adb provides many common debugging tools such as breakpoint setup, observing variables, single-step execution, and checking debugging output. The debugging process is the same as the debugging process for local applications. Many developers cannot even tell that the application is running on the target machine and not the host machine.<div class="Figure" id="Fig7"><div class="MediaObject" id="MO7"><img src="A978-1-4842-0100-8_3_Fig7_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig7_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-7.</span><div class="SimplePara">Android application debugging in Eclipse</div></div></div></div>
                </div><div id="Par65" class="Para">In the next sections we’re going to show examples of using adb commands and Eclipse debugging.</div></div></div></div></div><div id="Sec16" class="Section1 RenderAsSection1"><h2 class="Heading">Typical Development Tool Chains</h2><div id="Par66" class="Para">All stages of Android software development have corresponding tools to help developer complete tasks. Groups of development tools are called <span class="EmphasisTypeItalic">tool chains</span>, or <span class="EmphasisTypeItalic">toolsets</span>. The typical tool chains are listed in Table <span class="InternalRef"><a href="#Tab3">3-3</a></span>.<div id="Tab3" class="Table"><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Table 3-3.</span><div class="SimplePara">Typical Tool Chains for Android Software Development</div></div></div><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr class="header"><th><div class="SimplePara">Development Stage</div></th><th><div class="SimplePara">Function Description</div></th><th><div class="SimplePara">Typical Examples</div></th></tr></thead><tbody><tr class="noclass"><td><div class="SimplePara">Editing</div></td><td><div class="SimplePara">Writing and editing source code</div></td><td><div class="SimplePara">vi, Emacs, Windows Notepad</div></td></tr><tr class="noclass"><td><div class="SimplePara">Compiling and linking</div></td><td><div class="SimplePara">Compiling and linking source programs into executable binary files</div></td><td><div class="SimplePara">gcc, icc (Intel Compiler)</div></td></tr><tr class="noclass"><td><div class="SimplePara">Flashing</div></td><td><div class="SimplePara">Burning executable binary programs into the Android system’s ROM or flash to ensure the system automatically starts up</div></td><td><div class="SimplePara">J-fFlash, Sjflash</div></td></tr><tr class="noclass"><td><div class="SimplePara">Debugging</div></td><td><div class="SimplePara">Dynamic follow-up on the running status of the programs; checking on execution of programs and identifying causes behind program errors</div></td><td><div class="SimplePara">Gdb, adb, Kernel Debugger</div></td></tr><tr class="noclass"><td><div class="SimplePara">Optimizing</div></td><td><div class="SimplePara">Analyzing program performance and helping developers create faster and more efficient programs with little occupied space</div></td><td><div class="SimplePara">gprof, Intel Vtune<sup>™</sup> Amplifier</div></td></tr><tr class="noclass"><td><div class="SimplePara">Testing</div></td><td><div class="SimplePara">Helping testing personnel to identify mistakes in the programs and reduce HR costs</div></td><td><div class="SimplePara">CETK</div></td></tr><tr class="noclass"><td><div class="SimplePara">Verifying</div></td><td><div class="SimplePara">Verifying logical correctness and common errors of programs, especially under harsh testing and debugging environments</div></td><td><div class="SimplePara">Application Verifier</div></td></tr><tr class="noclass"><td><div class="SimplePara">Simulating/Emulating</div></td><td><div class="SimplePara">Simulating and emulating the running environment of Android hardware to help developers develop and debug</div></td><td><div class="SimplePara">Qemu, VirtualBox and VMware Player</div></td></tr></tbody></table></div>
          </div><div id="Par67" class="Para">Many toolsets are available, provided by different companies and organizations, each with its own characteristics. Icc, the Vtune Amplifier, and idb are provided by Intel, while gcc, gdb, and gproof by the free software organization GNU; and CETK, Application Verifier, Device Emulator are provided by Microsoft. Some of these tools are free like the GNU toolsets. Others, such as the Microsoft toolsets, must be purchased. These tools run on different platforms. For example, Jflash runs on the Linux platform while most of the Microsoft tools are based on Windows (including desktop Windows OS and Android OS-Windows CE/Mobile). And some are even cross-platform tools; for example, GNU toolsets can run on multiple platforms such as Linux, Windows, and Mac operating systems.</div><div id="Par68" class="Para">The way in which these toolsets are used falls into two categories: one is command line and the other is integrated development environment (IDE). Command line toolsets are executed by single commands entered in their command lines. In the case of IDEs, all functions are integrated into one tool, including editing, compiling, linking, deploying, and debugging, so that the full development process can be performed in one application. Most of the GNU tools run on command lines. Probably the most widely used IDE is Microsoft Visual Studio†. Anjuta DevStudio is a Linux-based IDE. The Android development tool, Eclipse, is an IDE that can run on multiple operating systems including Windows and Linux. In this book, we’re going to use the Windows version.</div><div id="Par69" class="Para">GNU toolsetscan run on multiple platforms; their openness, large usage scope, and compatibility with other tools have made them a common choice for Android application development.</div><div id="FPar1" class="FormalPara FormalParaRenderingStyle1 ParaTypeImportant"><div class="Heading">Tip</div><div id="Par70" class="Para">
              <span class="EmphasisTypeBold">GNU, GPL, and LGPL</span> GNU is by far the largest, most famous, and influential free software organization. It was created by Richard Stallman in 1985 who founded the Free Software Foundation (FSF) to break away from commercial software. You must comply with GNU software license before using GNU software.</div><div id="Par71" class="Para">GPL, short for GNU General Public License, is one of the GNU software licenses. GPL allows the public to enjoy the freedom of running, copying, and sharing software, obtaining source code, and improving the software and sharing it with the public. GPL also stipulates that as long as one part or the entirety of the altered content comes from the programs complied by GPL, then the sharing of the altered software must comply with GPL requirements, which means that you need to publish the changed source code and refrain from adding restrictions on the sharing of the improved software. GPL was the catalyst for developing and publishing the Linux OS and related software.</div><div id="Par72" class="Para">LGPL, which means Lesser GPL, is also one of the GNU software licenses. It is a variant of GPL. What’s different is that users enjoy private usage on LGPL-authorized free software. And the new software developed can be proprietary instead of free. Before using the free software, users must obtain LGPL or other variants of GPL. LGPL was initially used for some GNU program libraries (software libraries). So it was called Library GPL. Mozilla and OpenOffice.org are examples of software developed under LGPL.</div></div><div id="Par73" class="Para">GNU development tools are free. Anyone who agrees to GPL license can download them. GNU has also provided complete tool chains for software development on Android systems and Intel architecture systems. Such tools include compiler, assembly, linker, and debugging tools. They can be run independently from command lines or integrated into an IDE such as Eclipse. The GNU tool chains are listed in Table <span class="InternalRef"><a href="#Tab4">3-4</a></span>. <div id="Tab4" class="Table"><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Table 3-4.</span><div class="SimplePara">GNU Tool Chains</div></div></div><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr class="header"><th><div class="SimplePara">Function</div></th><th><div class="SimplePara">Component</div></th><th><div class="SimplePara">Description</div></th></tr></thead><tbody><tr class="noclass"><td><div class="SimplePara">Editing</div></td><td><div class="SimplePara">vi, Emacs, ed</div></td><td><div class="SimplePara">Text editor used for editing source code</div></td></tr><tr class="noclass"><td><div class="SimplePara">Compiling &amp; linking</div></td><td><div class="SimplePara">gcc</div></td><td><div class="SimplePara">A set of multi-programming language compilers</div></td></tr><tr class="noclass"><td><div class="SimplePara">Debugging</div></td><td><div class="SimplePara">gdb</div></td><td><div class="SimplePara">Debugger</div></td></tr><tr class="noclass"><td><div class="SimplePara">Optimizing</div></td><td><div class="SimplePara">gproof</div></td><td><div class="SimplePara">Optimization tool for analyzing program performance and helping developers to create faster-running programs</div></td></tr><tr class="noclass"><td><div class="SimplePara">Project Management</div></td><td><div class="SimplePara">make</div></td><td><div class="SimplePara">Auto management tool for software compilation</div></td></tr><tr class="noclass"><td><div class="SimplePara">System Building</div></td><td><div class="SimplePara">autotools</div></td><td><div class="SimplePara">All materials and files required for build projects</div></td></tr></tbody></table></div>
          </div><div id="Par74" class="Para">The components are further explained below.</div><div id="Sec17" class="Section2 RenderAsSection2"><h3 class="Heading">Editor</h3><div id="Par75" class="Para">Any text editing tool can be used to write and edit source code. The Linux platform has two categories of editors: one includes line editors such as ed and ex; the other includes full-screen editors such as vi, Emacs, and gedit. Line editors can only operate on one line, while full-screen editors can edit an entire screen of code and the edited files are displayed, thus overcoming the shortcomings of line editing and making it easier to use. Full-screen editors have a larger feature set than line editors.</div><div id="Par76" class="Para">In an IDE, editors are integrated into the tool and need not be used separately to write source code.</div></div><div id="Sec18" class="Section2 RenderAsSection2"><h3 class="Heading">Compiler and Linker</h3><div id="Par77" class="Para">The editing process involves grammar, semantic, and lexical analyses, generation and optimization of intermediate codes, symbol table management and error management. The GNU editor is gcc. Gcc is considered the standard compiler of Linux.</div><div id="Par78" class="Para">Gcc was initially the C language editor of GNU. Now it supports C, C++, Object-C, FORTRAN, Java, and ADA. To some degree, gcc is the combination of all GNU editors. Gcc compiles source code and does the linking process. Users can choose the command parameters to compile, link, and generate executable files.</div><div id="Par79" class="Para">Intel Compiler also optimized code paths to improve application performance on Intel platforms. Intel Compiler is bundled with the tools offering from Intel called Intel Integrated Native Developer Experience.</div></div><div id="Sec19" class="Section2 RenderAsSection2"><h3 class="Heading">Debugger</h3><div id="Par80" class="Para">A debugger makes it easier for programmers to debug programs. But it is not necessarily a tool required for code execution. During the compilation process, the time spent on debugging is more than the time on encoding. Therefore a full-featured debugger that’s easy to use is necessary.</div><div id="Par81" class="Para">The GNU debugger is gdb (abbreviation of GNU Debugger). It is also open source code and is a command line–based debugger. All debugging commands are realized through the commands of the control station.</div></div><div id="Sec20" class="Section2 RenderAsSection2"><h3 class="Heading">Build Manager</h3><div id="Par82" class="Para">GNU provides one build manager called make, a tool for controlling compilation of multiple software files. It is similar to Visual C++† project in Windows. In addition, it can automatically manage the contents, means, and timing of software compilation to help programmers so they can focus on coding instead of organizing compiling sequences.</div><div id="Par83" class="Para">Make can call gcc to compile and link source codes into executable files for the target machine according to the makefile defined by the developer.</div></div><div id="Sec21" class="Section2 RenderAsSection2"><h3 class="Heading">Makefile Auto Generation Tool</h3><div id="Par84" class="Para">Makefile can help make to perform the target file generation task. But encoding a makefile is not an easy job, especially for big projects. GNU provides a series of autotools to make makefiles. Such tools are aware of system configuration issues to help developers deal with migration issues. Autotools include aclocal, autoscan, autoconf, autoheader, automake, and libtool.</div><div id="Par85" class="Para">Several methods are used for generating target files from source code as shown in Figure <span class="InternalRef"><a href="#Fig8">3-8</a></span>.<div class="Figure" id="Fig8"><div class="MediaObject" id="MO8"><img src="A978-1-4842-0100-8_3_Fig8_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig8_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-8.</span><div class="SimplePara">Methods for generating target files using GNU tool chain</div></div></div></div>
              <div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par86" class="Para">Method 1: Use gcc (or Intel compiler ICC) to compile and link all source code files to generate executable target files</div></li><li><div id="Par87" class="Para">Method 2: Use an IDE, such as Eclipse, to compile a makefile and other configuration files and then use make to generate executable target files</div></li><li><div id="Par88" class="Para">Method 3: Use system build tools-autotools to make makefile and other configurations, and then use make to generate executable target files</div></li></ul></div>
            </div></div><div id="Sec22" class="Section2 RenderAsSection2"><h3 class="Heading">Optimizing Tools -- gprof</h3><div id="Par89" class="Para">To help developers optimize their programs, GNU provides a performance analyzer, gproof, one of the GNU binutils tools.</div><div id="Par90" class="Para">Gproof can measure the performance of programs and record the called times of each function and corresponding execution time so that the optimization effort can be centered on the most time-consuming portions. In addition, gproof can also generate function call relations during programming execution, including number of called times, to help programmers analyze how programs are executing. By relying on the function call relations, developers do not need to go through all the details of a program’s execution, improving their work efficiency. And this function is also helpful for maintaining old code or analyzing open source projects. With the calling diagram, you can get a basic understanding of the running framework and “skeleton” of the programs. Then analyzing them is less difficult, especially for code and open source projects you may not be familiar with.</div></div></div><div id="Sec23" class="Section1 RenderAsSection1"><h2 class="Heading">Overview, Installation, and Configuration of Android Application Development Tool Chains on Intel<sup>®</sup> Architecture</h2><div id="Par91" class="Para">Android provides a complete set of tool chains (or toolsets) for application development. Originally, Android ran only on ARM architecture hardware platforms. But now, to support Android tool chains on the Intel Atom hardware platform, Intel has added important plug-ins, libraries, and other auxiliary components. In addition, to give better play to the performance advantages of Intel hardware, Intel has added special development tools such as compilers and optimizers.</div><div id="Par92" class="Para">This chapter introduces the general processes and methods for Android application development on the Intel Atom platform. In the subsequent sections, we’re going to discuss the methods for using special Intel tools to achieve optimized performance and low energy consumption.</div><div id="Par93" class="Para">The Android and GNU development tool chains and the functions corresponding to Android cross development stages are shown in Table <span class="InternalRef"><a href="#Tab5">3-5</a></span>.<div id="Tab5" class="Table"><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Table 3-5.</span><div class="SimplePara">Comparison between GNU and Android Tool Chains</div></div></div><table border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr class="header"><th><div class="SimplePara">Stages of Cross Development</div></th><th><div class="SimplePara">GNU Tool Chains</div></th><th><div class="SimplePara">Android Development Tool Chains for Intel<sup>®</sup> Architecture</div></th><th><div class="SimplePara">Remarks</div></th></tr></thead><tbody><tr class="noclass"><td><div class="SimplePara">Editing</div></td><td><div class="SimplePara">vi, Emacs, ed</div></td><td rowspan="6"><div class="SimplePara">Eclipse, Android SDK</div></td><td rowspan="7"><div class="SimplePara">Android development tools and Intel related plug-ins</div></td></tr><tr class="noclass"><td><div class="SimplePara">Compiling and linking</div></td><td><div class="SimplePara">Gcc</div></td></tr><tr class="noclass"><td><div class="SimplePara">Project management</div></td><td><div class="SimplePara">Make</div></td></tr><tr class="noclass"><td><div class="SimplePara">Auto generation tool-makefile</div></td><td><div class="SimplePara">Autotools</div></td></tr><tr class="noclass"><td><div class="SimplePara">Deployment</div></td><td><div class="SimplePara">\</div></td></tr><tr class="noclass"><td><div class="SimplePara">Debugging</div></td><td><div class="SimplePara">gdb</div></td></tr><tr class="noclass"><td><div class="SimplePara">Simulation/emulation</div></td><td><div class="SimplePara">\</div></td><td><div class="SimplePara">Android Virtual Device (AVD)</div></td></tr><tr class="noclass"><td><div class="SimplePara">Optimization</div></td><td><div class="SimplePara">gprof</div></td><td><div class="SimplePara">Vtune<sup>™</sup> analyzer</div></td><td><div class="SimplePara">Intel series of tools</div></td></tr></tbody></table></div>
          </div><div id="Par94" class="Para">In addition to the differences with GNU tools shown above, Intel also provides some special performance libraries, including Intel<sup>®</sup> Integrated Performance Primitives (Intel<sup>®</sup> IPP), Intel<sup>®</sup> Math Kernel (Intel<sup>®</sup> MKL), and Intel<sup>®</sup> Threading Building Blocks (Intel<sup>®</sup> TBB). Some of the libraries have already provided special services such as the C++ template based threading services API in Intel TBB. Some of them use the Intel architecture instruction potential to achieve optimized performance, such as, for example, the Fast Fourier Transform (FFT) in Intel IPP. Some of the libraries still do not have direct Java interfaces. We’re going to discuss them in subsequent sections.</div><div id="Par95" class="Para">Table <span class="InternalRef"><a href="#Tab5">3-5</a></span> shows that the Android development tool chain for Intel architecture basically includes two parts: one part is the Android development tools. The Intel tools here include an Intel architecture emulator, development library, and other plug-ins. The other part is the independent Intel tools. While the Android development tools support most of the steps of application development such as editing, building, packaging, deployment, and debugging, the Intel tools involve mainly optimization.</div><div id="Par96" class="Para">Android development tools mean the software environment consisting of JDK (Java SE Development Kit), Android SDK (Software Development Kit), and an IDE (Integrated Development Environment)—Eclipse. Android development tools can run on Linux, OS X, and Windows systems. In this book, we’re going to discuss the Windows scenario.</div><div id="Par97" class="Para">The Android development tools can be run in command-line format or an IDE. The general development process of the Android command line tool in the Android SDK is shown in Figure <span class="InternalRef"><a href="#Fig9">3-9</a></span>. Eclipse, a graphic user interface tool, is typically the tool used for IDE mode, integrating the functions of editing, compiling, linking, deployment, and debugging. We’re going to discuss the method based on the IDE. <div class="Figure" id="Fig9"><div class="MediaObject" id="MO9"><img src="A978-1-4842-0100-8_3_Fig9_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig9_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-9.</span><div class="SimplePara">Development process of the Android SDK command line</div></div></div></div>
          </div><div id="Par98" class="Para">The directory structure of the Android SDK is shown below. It can be obtained by running the tree command from the command line.</div><div id="Par99" class="Para">├─add-ons</div><div id="Par100" class="Para">│ └─addon-google_apis-google-16</div><div id="Par101" class="Para">├─docs</div><div id="Par102" class="Para">│ ├─about</div><div id="Par103" class="Para">│ ├─assets</div><div id="Par104" class="Para">│ ├─design</div><div id="Par105" class="Para">│ ├─develop</div><div id="Par106" class="Para">│ ├─distribute</div><div id="Par107" class="Para">│ ├─guide</div><div id="Par108" class="Para">│ ├─images</div><div id="Par109" class="Para">│ ├─intl</div><div id="Par110" class="Para">│ ├─live</div><div id="Par111" class="Para">│ ├─out</div><div id="Par112" class="Para">│ ├─reference</div><div id="Par113" class="Para">│ ├─resources</div><div id="Par114" class="Para">│ ├─samples</div><div id="Par115" class="Para">│ ├─sdk</div><div id="Par116" class="Para">│ ├─shareables</div><div id="Par117" class="Para">│ ├─tools</div><div id="Par118" class="Para">│ └─training</div><div id="Par119" class="Para">├─extras</div><div id="Par120" class="Para">│ ├─android</div><div id="Par121" class="Para">│ └─google</div><div id="Par122" class="Para">├─platform-tools</div><div id="Par123" class="Para">│ ├─api</div><div id="Par124" class="Para">│ ├─lib</div><div id="Par125" class="Para">│ └─renderscript</div><div id="Par126" class="Para">├─platforms</div><div id="Par127" class="Para">│ └─android-16</div><div id="Par128" class="Para">├─samples</div><div id="Par129" class="Para">│ └─android-16</div><div id="Par130" class="Para">├─sources</div><div id="Par131" class="Para">│ └─android-16</div><div id="Par132" class="Para">├─system-images</div><div id="Par133" class="Para">│ └─android-16</div><div id="Par134" class="Para">├─temp</div><div id="Par135" class="Para">└─tools</div><div id="Par136" class="Para">├─ant</div><div id="Par137" class="Para">├─apps</div><div id="Par138" class="Para">├─Jet</div><div id="Par139" class="Para">├─lib</div><div id="Par140" class="Para">├─proguard</div><div id="Par141" class="Para">├─support</div><div id="Par142" class="Para">├─systrace</div><div id="Par143" class="Para">└─templates</div><div id="Par144" class="Para">The main files you should notice are:
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par145" class="Para">add-ons: API packages provided by Google, like Google Maps APIs</div></li><li><div id="Par146" class="Para">docs: help and explanation documents</div></li><li><div id="Par147" class="Para">platforms: API packages nd some example files for each SDK version</div></li><li><div id="Par148" class="Para">tools: some general tool files</div></li><li><div id="Par149" class="Para">usb_driver: AMD64 and Intel architecture driver files</div></li></ul></div>
          </div><div id="Par150" class="Para">The main files and their functions are described below.</div><div id="Sec24" class="Section2 RenderAsSection2"><h3 class="Heading">android.jar</h3><div id="Par151" class="Para">This file is located under the directory of <span class="EmphasisFontCategoryNonProportional">%android-sdk%\platforms</span>, and each version of Android has one android.jar. By looking at the .jar file you can understand the structure and organization of internal API packages. The string <span class="EmphasisFontCategoryNonProportional">%android-sdk%</span> here is the install directory of Android SDK while the corresponding directory for version 16 is <span class="EmphasisFontCategoryNonProportional">android-16</span>. For example, the author’s android.jar is located in:</div><div id="Par153" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">C:\Documents and Settings&gt;dir D:\Android\</span>
            </div><div id="Par154" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">......</span>
            </div><div id="Par155" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">2012-07-08 20:02 18,325,478 android.jar</span>
            </div><div id="Par157" class="Para">The android.jar is a standard zip package that contains compiled zipped files and all APIs. You can use WinRAR, or other archiving tool, to view its internal structure as shown in Figure <span class="InternalRef"><a href="#Fig10">3-10</a></span>. Its API kit is further divided into app, content, database, and so on.<div class="Figure" id="Fig10"><div class="MediaObject" id="MO10"><img src="A978-1-4842-0100-8_3_Fig10a_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig10a_HTML.jpg"/><img src="A978-1-4842-0100-8_3_Fig10b_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig10b_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-10.</span><div class="SimplePara">Content structure of android.jar</div></div></div></div>
            </div><div id="Sec25" class="Section3 RenderAsSection3"><h4 class="Heading">ddms.bat</h4><div id="Par158" class="Para">The debugging monitor service ddms.bat, shown in Figure <span class="InternalRef"><a href="#Fig11">3<span class="EmphasisTypeBold">-</span>11</a></span>, is integrated in Dalvik (the virtual device of the Android platform) and used for managing the processes of emulators or devices and assisting debugging work. It can eliminate some processes and choose one certain program for debugging, generate follow-up data, check threading data, or take snapshots of emulators or devices. <div class="Figure" id="Fig11"><div class="MediaObject" id="MO11"><img src="A978-1-4842-0100-8_3_Fig11_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig11_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-11.</span><div class="SimplePara">The debugging monitor service ddms.bat</div></div></div></div>
              </div></div><div id="Sec26" class="Section3 RenderAsSection3"><h4 class="Heading">adb.exe</h4><div id="Par159" class="Para">Android Debug Bridge (adb) is a multipurpose tool that can help you manage the state of devices or emulators. As mentioned before, this file is located under <span class="EmphasisFontCategoryNonProportional">%android-sdk%\platform-tools</span>. For example, the author’s adb.exe is located in the <span class="EmphasisFontCategoryNonProportional">C:\android\adt-bundle-windows-x86_64-20131030\sdk\platform-tools</span> directory, as shown in Figure <span class="InternalRef"><a href="#Fig12">3-12</a></span>. <div class="Figure" id="Fig12"><div class="MediaObject" id="MO12"><img src="A978-1-4842-0100-8_3_Fig12_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig12_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-12.</span><div class="SimplePara">File location of the adb.exe tool</div></div></div></div>
              </div></div><div id="Sec27" class="Section3 RenderAsSection3"><h4 class="Heading">aapt.exe</h4><div id="Par160" class="Para">With the Android resource packaging tool (aapt.exe), you can create .apk files that contain binary files and resource files for Android applications. The file location is the same as adb.exe.</div></div><div id="Sec28" class="Section3 RenderAsSection3"><h4 class="Heading">aidl.exe</h4><div id="Par161" class="Para">The Android interface description language (aidl.exe) is used for generating inter-process interface codes. The file location is the same as adb.exe.</div></div><div id="Sec29" class="Section3 RenderAsSection3"><h4 class="Heading">sqlite3.exe</h4><div id="Par162" class="Para">Android can create and use SQLite3 database files. Developers and users can easily access such SQLite data files. The file location is the same as ddms.bat.</div></div><div id="Sec30" class="Section3 RenderAsSection3"><h4 class="Heading">dx.bat</h4><div id="Par163" class="Para">Rewrite class byte code as Android byte code (saved in a dex file). The file location is the same with that of adb.exe.</div></div><div id="Sec31" class="Section3 RenderAsSection3"><h4 class="Heading">android.bat</h4><div id="Par164" class="Para">The android.bat file is under the same directory as ddms.bat. This command is used for displaying and creating the AVD. <div class="Figure" id="Fig13"><div class="MediaObject" id="MO13"><img src="A978-1-4842-0100-8_3_Fig13a_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig13a_HTML.jpg"/><img src="A978-1-4842-0100-8_3_Fig13b_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig13b_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-13.</span><div class="SimplePara">The command shows that two target machine development libraries are installed on the machine</div></div></div></div>
              </div></div></div></div><div id="Sec32" class="Section1 RenderAsSection1"><h2 class="Heading">Intel Environment Setup for Android (OS X Host)</h2><div id="Par165" class="Para">The Environment Setup for Android (OS X Host) Integrates common Intel and third-party tools into your preferred IDE for productivity-oriented designing, coding, and debugging. Supported IDEs include Eclipse and Android Studio. This beta release, formerly known as Beacon Mountain beta, will be part of the Intel<sup>®</sup> Integrated Native Developer Experience (Intel<sup>®</sup> INDE) for OS X hosts and can be downloaded at <span class="ExternalRef"><a href="https://software.intel.com/en-us/inde/environment-setup-osx"><span class="RefSource">
                <span class="EmphasisFontCategoryNonProportional">https://software.intel.com/en-us/inde/environment-setup-osx</span>
              </span></a></span>. Table <span class="InternalRef"><a href="#Tab6">3-6</a></span> provides a list of what is included in the Environment Setup for Android (OS-X Host). <div id="Tab6" class="Table"><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Table 3-6.</span><div class="SimplePara">Environment Setup for Android (OS-X Host)</div></div></div><table border="1"><colgroup><col/><col/></colgroup><tbody><tr class="noclass"><td><div class="SimplePara">Product Installs</div></td><td><div class="SimplePara">• Android Studio beta</div><div class="SimplePara">• Intel<sup>®</sup> Integrated Native Developer Experience(Intel<sup>®</sup> INDE) native project template for Android Studio</div><div class="SimplePara">• Android SDK</div><div class="SimplePara">• Android NDK</div><div class="SimplePara">• Intel<sup>®</sup> Hardware Accelerated Execution Manager(Intel<sup>®</sup> HAXM)</div><div class="SimplePara">• Apache Ant</div><div class="SimplePara">• Intel<sup>®</sup> INDE plugins for Eclipse</div></td></tr><tr class="noclass"><td><div class="SimplePara">IDEs</div></td><td><div class="SimplePara">• Eclipse</div><div class="SimplePara">• Android Studio beta</div></td></tr><tr class="noclass"><td><div class="SimplePara">Host Support</div></td><td><div class="SimplePara">• OS X</div></td></tr><tr class="noclass"><td><div class="SimplePara">Target Support</div></td><td><div class="SimplePara">• Android* 4.3 and up (based on ARM and Intel<sup>®</sup> architecture)</div></td></tr></tbody></table></div>
          </div></div><div id="Sec33" class="Section1 RenderAsSection1"><h2 class="Heading">Android Development on Linux-based Host Machines</h2><div id="Par166" class="Para">The following Android development tools for Linux-based host machines are available for download at:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par167" class="Para">Intel<sup>®</sup> Graphics Performance Analyzers (<span class="ExternalRef"><a href="https://software.intel.com/en-us/vcsource/tools/intel-gpa"><span class="RefSource">
                      <span class="EmphasisFontCategoryNonProportional">https://software.intel.com/en-us/vcsource/tools/intel-gpa</span>
                    </span></a></span>)</div></li><li><div id="Par168" class="Para">Intel<sup>®</sup> Hardware Accelerated Execution Manager (Intel<sup>®</sup> HAXM)(<span class="ExternalRef"><a href="https://software.intel.com/en-us/android/articles/intel-hardware-accelerated-execution-manager/"><span class="RefSource">
                      <span class="EmphasisFontCategoryNonProportional">https://software.intel.com/en-us/android/articles/intel-hardware-accelerated-execution-manager/</span>
                    </span></a></span>)</div></li><li><div id="Par169" class="Para">Intel<sup>®</sup> Threading Building Blocks (Intel<sup>®</sup> TBB)(<span class="ExternalRef"><a href="https://software.intel.com/en-us/intel-tbb"><span class="RefSource">
                      <span class="EmphasisFontCategoryNonProportional">https://software.intel.com/en-us/intel-tbb</span>
                    </span></a></span>)</div></li><li><div id="Par170" class="Para">Intel<sup>®</sup> C++ Compiler for Android (<span class="ExternalRef"><a href="https://software.intel.com/en-us/c-compiler-android/"><span class="RefSource">
                      <span class="EmphasisFontCategoryNonProportional">https://software.intel.com/en-us/c-compiler-android/</span>
                    </span></a></span>)</div></li><li><div id="Par171" class="Para">Intel<sup>®</sup> Integrated Performance Primitives (Intel<sup>®</sup> IPP)(<span class="ExternalRef"><a href="https://software.intel.com/en-us/intel-ipp"><span class="RefSource">
                      <span class="EmphasisFontCategoryNonProportional">https://software.intel.com/en-us/intel-ipp</span>
                    </span></a></span>)</div></li></ul></div>
          </div></div><div id="Sec34" class="Section1 RenderAsSection1"><h2 class="Heading">Intel<sup>®</sup> Integrated Native Developer Experience beta</h2><div id="Par172" class="Para">The Intel Integrated Native Developer Experience (Intel INDE) is a beta release of Intel’s cross-platform development suite designed to quickly and easily create applications targeting Android and Windows devices with native performance, outstanding battery-life, and exposure to unique platform capabilities. INDE provides a complete and consistent set of C++/Java tools, libraries, and samples for environment setup, code creation, compilation, debugging, and analysis on Intel architecture-based devices and select capabilities on ARM-based Android devices.</div><div id="Par173" class="Para">As a native cross-platform development suite, Intel INDE includes C++/Java native tools and samples for Android and Microsoft Windows, integration of tools into popular IDEs, and automatic updates to the latest tools and technology.</div><div id="Sec35" class="Section2 RenderAsSection2"><h3 class="Heading">Tools and Libraries</h3><div id="Par174" class="Para">Media: easily add visually compelling native video and audio extensions that work across the latest popular Android phones and tablets. The Intel INDE Media Pack for Android provides source code and samples to enhance apps with: <div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par175" class="Para">Camera and screen capture</div></li><li><div id="Par176" class="Para">Video editing</div></li><li><div id="Par177" class="Para">Video streaming</div></li><li><div id="Par178" class="Para">Audio fingerprinting</div></li><li><div id="Par179" class="Para">Support for Intel architecture and ARM-based Android devices running 4.3 and up.</div></li></ul></div>
            </div><div id="Par180" class="Para">Threading: efficiently implement higher-level, task-based parallelism using the Intel Threading Building Blocks (Intel TBB). Intel TBB is an award-winning C++ template library for the development of higher-performance, scalable applications. Apps created using the parallelism tool can run on Intel architecture and ARM processor-based Android 4.3 and up devices, as well as Microsoft Windows 7–8.1 client.</div><div id="Par181" class="Para">Compiling: bring a heritage of industry-leading performance to your Android apps with performance-oriented compiling with the Intel<sup>®</sup> C++ Compiler for Android. The compiler is source-code compatible with GCC, enabling easy usage. The GNU C++ Compiler is also provided through the Android NDK, which is a customization option in the Environment Setup component of Intel INDE. Apps created using the Intel C++ Compiler can run on Intel architecture-based devices running Android 4.3 and up.</div><div id="Par182" class="Para">Compute Code Builder: maximize performance with programmable graphics - develop code that executes on computing devices beyond the CPU using the Compute Code Builder. This tool assists with creating, compiling, debugging and analyzing compute APIs like Google Renderscript† and OpenCL†. The compute code builder can be used in standalone mode or integrated with Microsoft Visual Studio or Eclipse. Apps created can run on Intel architecture-based Android 4.4 devices, as well as Microsoft Windows 7–8.1 client. Visit Intel’s Getting Started Guide for more information.
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par183" class="Para">Analyzing and Debugging: Use Analysis and optimization tools suite includes the Intel Graphics Performance Analyzer (Intel GPA) System Analyzer, Intel GPA Platform Analyzer, Intel GPA Frame Analyzer, and Intel Frame Debugger. You can use them to do the following:</div></li><li><div id="Par184" class="Para">Real-time trace analysis of code execution, CPU/GPU usage and task data, and more</div></li><li><div id="Par185" class="Para">Frame-capture analysis and debugging</div></li><li><div id="Par186" class="Para">Platform-wide and application-specific GPU metric analysis and graphics pipeline overrides</div></li></ul></div>
            </div><div id="Par187" class="Para">Apps created using the analysis and debugging tools can run on Intel architecture-based devices running Microsoft Windows 7–8.1 or Android 4.4.</div></div><div id="Sec36" class="Section2 RenderAsSection2"><h3 class="Heading">Setup</h3><div id="Par188" class="Para">Setting up an environment for Intel INDE is easy. You can build your custom environment in minutes instead of hours: <div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par189" class="Para">Selectively choose tools to install, allowing for a customized environment.</div></li><li><div id="Par190" class="Para">Choose from the Google Android SDK (including Eclipse), vs-Android plug-in for Microsoft Visual Studio, Android NDK, Android Design, Apache Ant, and Intel HAXM.</div></li></ul></div>
            </div><div id="Par191" class="Para">Apps created using the environment setup can run on Intel architecture and ARM-based targets running Android 4.3 and up.</div></div><div id="Sec37" class="Section2 RenderAsSection2"><h3 class="Heading">Intel INDE Installation</h3><div id="Par192" class="Para">The following sections describe the Intel INDE installation process.</div><div id="Sec38" class="Section3 RenderAsSection3"><h4 class="Heading">Downloading Intel INDE</h4><div id="Par193" class="Para">Go to <span class="ExternalRef"><a href="https://software.intel.com/en-us/intel-inde"><span class="RefSource">
                    <span class="EmphasisFontCategoryNonProportional">https://software.intel.com/en-us/intel-inde</span>
                  </span></a></span>, click the Download link, and accept the license agreements. You will receive an e-mail with a download link, as shown in Figure <span class="InternalRef"><a href="#Fig14">3-14</a></span>. <div class="Figure" id="Fig14"><div class="MediaObject" id="MO14"><img src="A978-1-4842-0100-8_3_Fig14_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig14_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-14.</span><div class="SimplePara">Download screen for INDE</div></div></div></div>
              </div></div><div id="Sec39" class="Section3 RenderAsSection3"><h4 class="Heading">Installing Intel INDE</h4><div id="Par194" class="Para">Run the downloaded file: <span class="EmphasisFontCategoryNonProportional">IntelHubSetup.exe</span>. An Intel INDE window displays license terms and conditions, as shown in Figure <span class="InternalRef"><a href="#Fig15">3-15</a></span>. <div class="Figure" id="Fig15"><div class="MediaObject" id="MO15"><img src="A978-1-4842-0100-8_3_Fig15_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig15_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-15.</span><div class="SimplePara">INDE install window</div></div></div></div>
              </div><div id="Par195" class="Para">Check the box to agree to the license terms and conditions, and click Install. The setup process starts, and several command-line windows flash. An Intel INDE icon and an NDK.cmd icon are created on your desktop. When the process is complete, you are ready to launch, as shown in Figure <span class="InternalRef"><a href="#Fig16">3-16</a></span>. <div class="Figure" id="Fig16"><div class="MediaObject" id="MO16"><img src="A978-1-4842-0100-8_3_Fig16_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig16_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-16.</span><div class="SimplePara">INDE setup complete</div></div></div></div>
              </div></div><div id="Sec40" class="Section3 RenderAsSection3"><h4 class="Heading">Launching Intel INDE</h4><div id="Par196" class="Para">Click the Launch icon, and the main Intel INDE window will start as shown in Figure <span class="InternalRef"><a href="#Fig17">3-17</a></span>. <div class="Figure" id="Fig17"><div class="MediaObject" id="MO17"><img src="A978-1-4842-0100-8_3_Fig17_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig17_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-17.</span><div class="SimplePara">Main window for INDE</div></div></div></div>
              </div><div id="Par197" class="Para">Follow each tool and application to download the necessary software. You’re ready to begin cross-platform development.</div></div><div id="Sec41" class="Section3 RenderAsSection3"><h4 class="Heading">Configure Eclipse</h4><div id="Par198" class="Para">
                <div class="OrderedList"><div class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"><div id="Par199" class="Para">Start Eclipse and select the Window menu, then Preferences, as shown in Figure <span class="InternalRef"><a href="#Fig18">3-18</a></span>.</div></div><div class="ClearBoth"> </div></div></div>
                <div class="Figure" id="Fig18"><div class="MediaObject" id="MO18"><img src="A978-1-4842-0100-8_3_Fig18_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig18_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-18.</span><div class="SimplePara">Startup page for configuring Eclipse</div></div></div></div>
                <div class="OrderedList"><div class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"><div id="Par200" class="Para">A Preferences dialog box will pop up. Select the Android branch and then type the correct path in the SDK Location box (usually this is auto-populated), as shown in Figure <span class="InternalRef"><a href="#Fig19">3-19</a></span>. Note: After clicking the Android branch, a dialog box will pop up. Click Proceed to continue.</div></div><div class="ClearBoth"> </div></div></div>
                <div class="Figure" id="Fig19"><div class="MediaObject" id="MO19"><img src="A978-1-4842-0100-8_3_Fig19_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig19_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-19.</span><div class="SimplePara">Directory Location Setting of Android SDK</div></div></div></div>
              </div></div><div id="Sec42" class="Section3 RenderAsSection3"><h4 class="Heading">Create AVD (Emulator)</h4><div id="Par201" class="Para">
                <div class="OrderedList"><div class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"><div id="Par202" class="Para">On the menu bar, select Window, then AVD Manager, as shown in Figure <span class="InternalRef"><a href="#Fig20">3-20</a></span>.</div></div><div class="ClearBoth"> </div></div></div>
                <div class="Figure" id="Fig20"><div class="MediaObject" id="MO20"><img src="A978-1-4842-0100-8_3_Fig20_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig20_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-20.</span><div class="SimplePara">Start menu for creating emulator</div></div></div></div>
                <div class="OrderedList"><div class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"><div id="Par203" class="Para">The Android Virtual Device Manager dialog box will pop up, as shown in Figure <span class="InternalRef"><a href="#Fig21">3-21</a></span>. Click the New button.</div></div><div class="ClearBoth"> </div></div></div>
                <div class="Figure" id="Fig21"><div class="MediaObject" id="MO21"><img src="A978-1-4842-0100-8_3_Fig21_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig21_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-21.</span><div class="SimplePara">Initial page of emulator list</div></div></div></div>
                <div class="OrderedList"><div class="ListItem"><span class="ItemNumber">3.</span><div class="ItemContent"><div id="Par204" class="Para">When the Create new Android Virtual Device (AVD) dialog box displays, as shown in Figure <span class="InternalRef"><a href="#Fig22">3-22</a></span>, type an appropriate name and, for Target, select the version of Android you wish to use. The CPU/ABI box will automatically display Intel Atom(x86). The size field for the SD card is the amount of space allocated for it on the hard disk (in this example, 1024 MB). If your target device has a larger SD card, enter the correct size. When the settings are correct, click Create AVD to close the dialog box.</div></div><div class="ClearBoth"> </div></div></div>
                <div class="Figure" id="Fig22"><div class="MediaObject" id="MO22"><img src="A978-1-4842-0100-8_3_Fig22_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig22_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-22.</span><div class="SimplePara">Creation parameter setting for emulator</div></div></div></div>
                <div class="OrderedList"><div class="ListItem"><span class="ItemNumber">4.</span><div class="ItemContent"><div id="Par205" class="Para">The Android Virtual Device Manager will then display, as shown in Figure <span class="InternalRef"><a href="#Fig23">3-23</a></span>, and you can see the newly added item in the list. Click the close button (the x) to close the dialog box.</div></div><div class="ClearBoth"> </div></div></div>
                <div class="Figure" id="Fig23"><div class="MediaObject" id="MO23"><img src="A978-1-4842-0100-8_3_Fig23_HTML.jpg" alt="A978-1-4842-0100-8_3_Fig23_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-23.</span><div class="SimplePara">Display of created list of emulator</div></div></div></div>
              </div></div></div></div><div id="Sec43" class="Section1 RenderAsSection1"><h2 class="Heading">Summary</h2><div id="Par206" class="Para">So far, you have finished installing the development environment tools for an emulator target machine. The next chapter discusses how, if your target machine is a real device (for example, a smartphone or tablet), you need to install and configure the development environment for developing and testing apps on that device.</div></div></div></body></html>
