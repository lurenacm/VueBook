<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><title>The Low-Power Design of Android Application and Intel Graphics Performance Analyzers (Intel GPA): Assisted Power Optimization</title><link href="springer_epub.css" type="text/css" rel="styleSheet"/></head><body><div class="ChapterContextInformation"><div class="ContextInformation" id="Chap13"><div class="ChapterCopyright">© Ryan Cohen 2014</div><span class="ContextInformationAuthorEditorNames"><span class="Author"><span class="AuthorName">Ryan Cohen</span> and </span><span class="Author"><span class="AuthorName">Tao Wang</span></span></span><span class="ContextInformationBookTitles"><span class="BookTitle" xml:lang="en">Android Application Development for the Intel<sup>®</sup> Platform</span></span><span class="ChapterDOI">10.1007/978-1-4842-0100-8_13</span></div></div><!--Begin Abstract--><div class="MainTitleSection"><h1 class="ChapterTitle" xml:lang="en">13. The Low-Power Design of Android Application and Intel Graphics Performance Analyzers (Intel GPA): Assisted Power Optimization</h1></div><div class="AuthorGroup"><div class="AuthorNames"><span class="Author"><span class="AuthorName">Ryan Cohen</span><sup>1 <span class="ContactIcon"/></sup> and </span><span class="Author"><span class="AuthorName">Tao Wang</span><sup>1 <span class="ContactIcon"/></sup></span></div><div class="Affiliations"><div class="Affiliation" id="Aff1"><span class="AffiliationNumber">(1)</span><div class="AffiliationText">OR, USA</div></div><div class="ClearBoth"> </div></div></div><!--End Abstract--><div class="Fulltext"><div id="Par2" class="Para">Unlike general-purpose computers that use an AC power supply, not all mobile devices can be directly connected to AC power; it cannot be assumed that the power supply is inexhaustible. In addition, heat dissipation must be considered for mobile devices. If power consumption is too high, it requires the system to increase heat dissipation, and at some point it may reach a point where this is not allowed. Due to strict constraints on the system’s overall power consumption, <span class="EmphasisTypeItalic">low-power design</span>, commonly known as <span class="EmphasisTypeItalic">power saving</span>, is an important element of applications for mobile devices; in many cases it is a rigid requirement or the basis for survival. For example, it would be difficult to imagine a mobile phone the market would accept that could support only a few hours’ time.</div><div id="Par3" class="Para">On the other hand, Intel Mobile hardware and software provide a basis for low-power design. The Intel Atom processor provides hardware support for low power, and low-power support is a major feature of Android. Both provide a good platform for low-power design for mobile applications.</div><div id="Par4" class="Para">This chapter is organized as follows: first an overview of and introduction to low-power design, then a discussion of the Android power-control mechanisms, and finally a discussion of how to achieve the goal of low-power application design.</div><div id="Sec1" class="Section1 RenderAsSection1"><h2 class="Heading">Overview of Low-Power Design</h2><div id="Par5" class="Para">Let’s look at the power-consumption characteristics of mobile systems. For a mobile device, the processor, radio communication, and the screen are the three main components of its power consumption (power). The processor and its ancillary equipment are responsible for most of the battery power consumption. Therefore, this chapter focuses on the power consumption of the processor and its ancillary equipment (abbreviated here as <span class="EmphasisTypeItalic">processor power consumption</span>).</div><div id="Sec2" class="Section2 RenderAsSection2"><h3 class="Heading">The Basics of Consumption</h3><div id="Par6" class="Para">
              <span class="EmphasisTypeItalic">Battery life</span> mainly refers to the running time that a mobile device such as a laptop, an MP3 player, or a mobile phone, equipped with its own battery alone, can maintain without an external power adapter. In general, the factors that affect the machine’s battery life include the battery itself as well as the machine power consumption (watts/hour).</div><div id="Par7" class="Para">For a semiconductor product, the power consumption of a digital circuit is composed of two parts. The first part is , from the perspective of integrated circuit technology, which is power consumption caused by <span class="EmphasisTypeItalic">drain current</span> (leakage current), which is part of the electronic circuit (such as CMOS). The ability to control this power consumption is mainly determined by the production processes and materials used. The second part of a digital circuit’s power consumption is . Many factors affect this part, such as circuit design, circuit complexity, and working clock frequency.</div><div id="Par8" class="Para">The dynamic power of the processor (or CPU), also known as <span class="EmphasisTypeItalic">switching power</span>, referred to as <span class="EmphasisTypeItalic">power consumption</span>, is determined by the following empirical equation:</div><div id="Par9" class="Para">In this formula, <span class="EmphasisTypeItalic">P</span> is the processor power consumption, <span class="EmphasisTypeItalic">a</span> is an adjustment parameter relating to the circuit, <span class="EmphasisTypeItalic">C</span> is total gate capacitance of a single clock cycle (which is fixed for a processor), <span class="EmphasisTypeItalic">F</span> is the processor operating frequency, and <span class="EmphasisTypeItalic">V</span> is operating voltage. As you can see, the processor’s power consumption is proportional to the square of the operating voltage, proportional to the operating frequency.</div><div id="FPar1" class="FormalPara FormalParaRenderingStyle1 ParaTypeImportant"><div class="Heading">Tip</div><div id="Par10" class="Para">With regard to processor power consumption, there is a related concept called . TDP is easy to confuse with CPU power consumption. Although both are indicators used to measure processor power, and both use watts (W) as a unit, TDP has a different meaning than processor power consumption.</div><div id="Par11" class="Para">TDP is a heat-release indicator’s reflection of a processor. By definition, it is the heat released by a processor when it reaches maximum load. The processor TDP power consumption is not the real power consumption of the processor. Processor power (power) is a physical parameter, which is equal to the value of current flowing through the processor core and the product of the voltage value of the processor core, and it reflects the actual power consumption of energy in the unit of time. TDP is the heat generated by the processor’s thermal effect of current and other forms of heat release. Obviously, the processor TDP is less than the power consumption of the processor.</div><div id="Par12" class="Para">TDP cooling system requirements are an important factor for hardware designers and manufacturers to consider. But this chapter discusses the actual consumption of electrical power—processor power consumption—not TDP.</div></div><div id="Par13" class="Para">From the processor power-consumption formula, the adjust parameter <span class="EmphasisTypeItalic">a</span> and total gate capacitance <span class="EmphasisTypeItalic">C</span> are determined by the processor design and materials. For a processor, parameters <span class="EmphasisTypeItalic">a</span> and <span class="EmphasisTypeItalic">C</span> are fixed; if you want to reduce power consumption, you must start from the operating frequency (<span class="EmphasisTypeItalic">F</span>) and operating voltage (<span class="EmphasisTypeItalic">V</span>), which are the starting point for many low-power technologies.</div><div id="Par14" class="Para">In general, the methods to achieve the greater energy efficiency for a CMOS processor are as follow:
<div class="OrderedList"><div class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"><div id="Par15" class="Para">Reduce the voltage or the processor clock frequency.</div></div><div class="ClearBoth"> </div></div><div class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"><div id="Par16" class="Para">Internally disable some of the currently executing functions that do not require a functional unit.</div></div><div class="ClearBoth"> </div></div><div class="ListItem"><span class="ItemNumber">3.</span><div class="ItemContent"><div id="Par17" class="Para">Allow part of the processor to be fully disconnected from the main power supply to eliminate leakage.</div></div><div class="ClearBoth"> </div></div><div class="ListItem"><span class="ItemNumber">4.</span><div class="ItemContent"><div id="Par18" class="Para">Improve processor circuit design and manufacturing processes; obtain energy efficiency by applying the principles of physics.</div></div><div class="ClearBoth"> </div></div></div>
            </div><div id="Par19" class="Para">There are two types of tactics for managing processor power (power consumption). One is the use of static power-management mechanisms. Such mechanisms are invoked by the user and do not depend on processor activity. One example of a static mechanism is a power-saving mode to conserve power. The ­power-saving mode can be entered with a single instruction and exited through receipt of an interrupt or other event.</div><div id="Par20" class="Para">Another tactic for managing processing power is to use dynamic power-management mechanisms. Such mechanisms are based on the dynamic activity of the processor power-consumption control. For example, when the command is run, if some part of the processor logic does not need to run, the processor may switch off these specific sections.</div></div><div id="Sec3" class="Section2 RenderAsSection2"><h3 class="Heading">Power Consumption Control Technology</h3><div id="Par21" class="Para">To help you understand the power-consumption basics for semiconductors (including processors), let’s look at the ways you can implement power consumption control technology in hardware. These pathways are discussed in the following sections.</div><div id="Sec4" class="Section3 RenderAsSection3"><h4 class="Heading">Dynamic Voltage/Frequency Scaling Technology</h4><div id="Par22" class="Para">is a way of controlling power consumption by adjusting (reducing) the operating frequency of the processor so that it runs at less than the peak frequency, thus reducing processor power. This technology was first used on laptops and is now more and more widely used in mobile devices.</div><div id="Par23" class="Para">DFS technology has other uses besides saving energy on the processor. It can be used in a quiet computing environment on the machine or in a light load condition to reduce cooling costs as well as the overall energy demand. When a system has inadequate cooling and the temperature is close to a critical value, this technology helps to reduce heat buildup, thus preventing the machine from experiencing critical temperature problems. Many overclocking systems also use this technique to achieve temporary supplemental cooling.</div><div id="FPar2" class="FormalPara FormalParaRenderingStyle1 ParaTypeImportant"><div class="Heading">Tip</div><div id="Par24" class="Para">In contradiction to, but related to, DFS technology is <span class="EmphasisTypeItalic">overclocking</span>. This technology upgrades processor (dynamic) power to exceed the manufacturer’s prescribed design limits and improve processor performance. There is an important difference between DFS and overclocking: overclocking is in the front-side bus (mainly because multiples usually are locked) in a modern computer system, whereas DFS is used in the multiplier to completion. Moreover, overclocking is often static; DFS is usually dynamic.</div></div><div id="Par25" class="Para">In practice, the Advanced Configuration and Power Interface (ACPI) specifies that the C0 working state of modern processors can be divided into named performance states (P-states) and throttling states (T-states). The P-state allows you to reduce the clock frequency, and the T-state does so by inserting a STPCLK (stop the clock) signal to temporarily close the clock signal and further suppress processor power consumption (but not the actual clock frequency). Intel is also working with Google on improving power management for Android and has created drivers for three CPU standby states: Active Standby (S0i1), Always On Always Connected (AOAC) Standby (S0i2), and Deep Sleep Standby (S0i3).</div><div id="Par26" class="Para">As described, power consumption is mainly caused by leakage current due to the presence of static power; dynamic power is only part of the total power of the chip. When the chip size becomes smaller, the CMOS threshold level is lowered, and the influence of the leakage current appears more obvious. Especially for the current chip-manufacturing process, which is under the micron level, dynamic power is only about two thirds of the total power of the chip, which limits the effect of frequency scaling.</div><div id="Par27" class="Para"> (DVS)is another way to control processor power consumption. This is accomplished by adjusting (lowering) the operating voltage of the processor to reduce processor power.</div><div id="Par28" class="Para">DFS does not have much value simply as a way to save dynamic power. Taking into account the important role of <span class="EmphasisTypeItalic">V</span>
                <sup>2</sup> in the dynamic power formula, as well as the fact that there has been in-depth optimization of the low-power idle state for modern processors to save a lot of power consumption in DFS, you need to consider DVS. Reducing the processor clock frequency also provides voltage reduction space (because in a certain range, the maximum operating frequency a processor can support is increased with the increase of the processor’s supply voltage). Voltage scaling and frequency scaling can be used in conjunction to form a comprehensive power-control method: dynamic voltage/frequency discharge reduction, or . This technology is also known as <span class="EmphasisTypeItalic">Intel processor CPU throttling</span>.</div><div id="Par29" class="Para">Dynamic voltage/frequency scaling technology affects performance. This technique reduces the number of instructions issued by the processor at a given time, thereby causing a decline in processing performance (speed). Therefore, it is usually used at a lower processor load (such as when the system is running in the idle state).</div></div><div id="Sec5" class="Section3 RenderAsSection3"><h4 class="Heading">Clock Gating</h4><div id="Par30" class="Para">is another way to achieve energy savings, in this case by closing and opening the module clock and power control. This technology was applied in the first family of applications, such as the OMAP3-like traditional phone chip; the Intel Pentium 4 processor also used it.</div><div id="Par31" class="Para">For CMOS processor components, the power consumed to change the level state is much greater than the power consumed to maintain the level state, because the clock signal is extremely frequent when changing level state. If you use clock-gating technology in the current clock cycle, if the system does not use some of the logic module, the module clock signal is cut off, creating a closed circuit in the module so the logic switch does not change state. You only need to retain the leakage current while the switching power consumption is close to zero, to reduce power consumption. When there is work to be done, the module clock is reactivated. This process is also known as <span class="EmphasisTypeItalic">clipping</span> (or <span class="EmphasisTypeItalic">pruning</span>) <span class="EmphasisTypeItalic">the clock tree</span>. In a sense, clock gating is an extreme case of the variable frequency clock, but the two values are zero and the maximum frequency.</div><div id="Par32" class="Para">This technique requires that each module—known as a <span class="EmphasisTypeItalic">functional unit block (FUB)</span>—contain the clock gate logic circuit. That is, the technique of clipping the clock tree must be ensured by the additional logic components.</div><div id="Par33" class="Para">Clock gating has several forms. With the software manual clock-gating method, the driver controls when to turn on or off the various clocks used by the specified idle controller. The other method is automatic clock gating: the hardware can be informed or can detect whether there is work to do and then close the gate if you specify that the clock is no longer needed. For example, an internal bridge or bus may use the automatic clock-gating method so that it is always gated off until the processor or DMA engines need to use it. Peripheral devices on the bus may be closed by the driver in the gated code if the software did not use them.</div></div><div id="Sec6" class="Section3 RenderAsSection3"><h4 class="Heading">Energy-Saving Circuit Design and Manufacturing Processes</h4><div id="Par34" class="Para">Chip circuit design choices and manufacturing processes can improve energy savings on a physical level. One of these design choices is to use an ultra-low voltage (ULV) processor. ULV series processors reduce the processor core voltage and reduce the number of processor cores and even size, to realize power-consumption control from the hardware (at the physical level).</div><div id="Par35" class="Para">In addition, similar to the ULV processor, a 45-nanometer manufacturing process reduces processor power consumption at the hardware level. The chip consumes less power and has longer battery life, has more transistors, and is smaller. The Intel Atom Bay Trail processor uses a 22-nanometer manufacturing process for energy-saving technologies (14nm technology will be used on the next generation of processors). With the further enhancement of manufacturing processes and manufacturing precision, chips are getting smaller and smaller, while at the same time, physical power consumption is becoming lower and lower.</div><div id="Par36" class="Para">With an understanding of hardware power control, you can look at system power-control technology. Some of these techniques are at the hardware level, some are at the operating system layer, and some are at the system layer and include both software and hardware.</div></div><div id="Sec7" class="Section3 RenderAsSection3"><h4 class="Heading">Intel SpeedStep and Enhanced Intel SpeedStep Technology</h4><div id="Par37" class="Para">Intel SpeedStep Technology was developed to provide power control for Intel CPUs; the technology is now generally referred to as Enhanced Intel SpeedStep Technology (EIST). It was first used in the Intel Pentium M, Pentium 4 6xx Series, and Pentium D processors. Intel Core, Intel Atom, and other processor series have also adopted it. EIST mainly takes advantage of dynamic voltage and frequency scaling; the basic principle is to adjust processor voltage and frequency to reduce power consumption and heat. Of course, with the reduction of voltage and frequency, processing speed is also reduced. This technology has undergone several generations of development, as discussed next.</div><div id="Sec8" class="Section4 RenderAsSection4"><h5 class="Heading">First-Generation Intel SpeedStep Technology</h5><div id="Par38" class="Para">The original Intel SpeedStep Technology allows the processor to switch freely between two modes of operation: AC status, which offers the highest performance mode (Maximum Performance mode); and battery status (Battery Optimized mode). These two modes are automatically selected according to the computer’s power source: external power supply or battery. Maximum Performance mode is the approximate performance when the computer is connected to AC power (that is, always powered by an external power supply). Battery Optimized mode is used when the computer is using the minimum battery power to achieve the best performance. Usually, when switching modes with Intel SpeedStep Technology, the power of the processor is reduced by 40% while still maintaining the 80% of peak performance.</div><div id="Par39" class="Para">The conversion speed of mode switching is very fast—only 1/2000 of a second, so the user does not feel the transformation. Even if a program’s performance requirements are sensitive (for example, playing DVD movies), this conversion process does not affect program operation. In addition, users can set up their own mode to use the battery in Maximum Performance mode or an external power supply in Battery Optimized mode. To do so, the user selects a mode onscreen, without having to restart the computer.</div></div><div id="Sec9" class="Section4 RenderAsSection4"><h5 class="Heading">Second-Generation Intel SpeedStep Technology (EIST)</h5><div id="Par40" class="Para">EIST begins dynamic switching between the two modes of performance for voltage and frequency, according to the processor load in real time. Using this technique, the battery-powered processor load automatically switches to the maximum operating frequency and voltage. It can also switch to the lowest operating frequency and voltage automatically, according to the processor load in the external power supply. In other words, the technical processing of the operating frequency and voltage change is no longer determined by the type of power source.</div></div><div id="Sec10" class="Section4 RenderAsSection4"><h5 class="Heading">Third-Generation Intel SpeedStep Technology (Improved EIST)</h5><div id="Par41" class="Para">In addition to the two basic modes of operation, the improved EIST provides a variety of intermediate modes and supports multiple frequencies, speeds, and voltage settings (controlled by the processor voltage adjustment mechanism), according to the strength of the processor’s current load. It automatically switches the operating mode.</div><div id="Par42" class="Para">EIST includes a number of software and hardware technologies to ensure that it runs smoothly, including the system BIOS, the user terminal software, ASIC control, and chipset support. The software program itself does not need to make any changes; it can easily use this technique. At the same time, EIST also requires the operating system to cope with, for example, its processor load detection, which is accomplished through the operating system.</div></div></div><div id="Sec11" class="Section3 RenderAsSection3"><h4 class="Heading">APM and the ACPI Standard</h4><div id="Par43" class="Para">To make low power consumption possible for mobile computing systems, hardware and operating systems need to work together. Coordinating operating systems and hardware for both power consumption and power management requires a unified set of interface specifications. The earliest specification was Advanced Power Management (APM), released by Intel and Microsoft; it is a set of APIs, running on IBM-compatible PC operating systems and BIOS synergy to manage power consumption. The current specification is Advanced Configuration and Power Interface (ACPI), which comes from the development of APM.</div><div id="Par44" class="Para">ACPI is an open industry standard for power-management services. It is compatible with multiple operating systems; the initial goal is to use it with personal computers. ACPI has power-management tools and a hardware abstraction layer. The operating system has its own power-management model. It sends demand controls to hardware via ACPI and then observes the hardware status as an input, to control the power of computers and peripherals. ACPI in the entire computer system structure is illustrated in Figure <span class="InternalRef"><a href="#Fig1">13-1</a></span>.<div class="Figure" id="Fig1"><div class="MediaObject" id="MO2"><img src="A978-1-4842-0100-8_13_Fig1_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig1_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-1.</span><div class="SimplePara">ACPI structure</div></div></div></div>
              </div><div id="Par45" class="Para">ACPI supports the following five basic global power states:
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par46" class="Para">
                      <span class="EmphasisTypeItalic">G3</span>: Mechanical off state; the system does not consume power.</div></li><li><div id="Par47" class="Para">
                      <span class="EmphasisTypeItalic">G2</span>: Soft off state; the entire operating system restarts to restore the machine to working conditions. This state has four substates:</div></li><li><div id="Par48" class="Para">
                      <span class="EmphasisTypeItalic">S1</span>: No system context; the missing low wake-up delay state.</div></li><li><div id="Par49" class="Para">
                      <span class="EmphasisTypeItalic">S2</span>: Lost low CPU and system cache status wake-up delay state.</div></li><li><div id="Par50" class="Para">
                      <span class="EmphasisTypeItalic">S3</span>: In addition to the main memory, all other system status is lost; low wake-up delay state.</div></li><li><div id="Par51" class="Para">
                      <span class="EmphasisTypeItalic">S4</span>: Low-power sleep mode; all devices are turned off.</div></li><li><div id="Par52" class="Para">
                      <span class="EmphasisTypeItalic">G1</span>: Sleep state; the system appears to be off; the low-power state. The time required to return to the normal operating state is inversely proportional to the power consumption of the low-power state.</div></li><li><div id="Par53" class="Para">
                      <span class="EmphasisTypeItalic">G0</span>: The working state; the system is fully available.</div></li><li><div id="Par54" class="Para">
                      <span class="EmphasisTypeItalic">Retention state</span>: The system does not comply with ACPI.</div></li></ul></div>
              </div><div id="Par55" class="Para">The typical power-management program includes a viewer for messages received by ACPI that describe the behavior of the system. Also included is a decision model based on observations to determine power-management behavior.</div><div id="Par56" class="Para">Popular operating systems and software platforms, such as Windows and Android, all support ACPI.</div></div><div id="Sec12" class="Section3 RenderAsSection3"><h4 class="Heading">Low-Power Operating System States</h4><div id="Par57" class="Para">When the task is idle (or in an inactive state), the computer system achieves energy savings by entering the various low-power operating modes. These low-power modes are sometimes collectively referred to as <span class="EmphasisTypeItalic">sleep mode</span>. They are between the states in which system is fully booted and completely closed, with a variety of forms; each form has its own characteristics to meet users’ various needs. These modes are described in the following sections.</div><div id="Sec13" class="Section4 RenderAsSection4"><h5 class="Heading">Standby</h5><div id="Par58" class="Para">When the system is in standby mode, it cuts off power to the hardware components, thereby reducing computer power consumption. Standby cuts off peripherals, the monitor, and even the power of the hard drive, but it retains the power of the computer’s memory to ensure that there is no loss of work data.</div><div id="Par59" class="Para">The main advantage of standby mode is that recovery time is short—it takes just a few seconds for the system to be restored to its previous state. The disadvantage is that standby mode needs the memory power supply, so memory contents are not saved to the folder and therefore do not affect the running speed of memory reload. However, if a power failure occurs in this mode, all unsaved memory contents are lost. Therefore, standby is also known as <span class="EmphasisTypeItalic">suspend to RAM</span> (STR).</div><div id="Par60" class="Para">When the system is in standby mode, the hard disk and other equipment are in the power-wait state until a wakeup call is received. The power supply, processor, graphics, and other fans are working, and the keyboard indicator is lit. You can press any keyboard key or move the mouse to wake up the computer. The hard disk is repowered, and allows memory, processors, and other devices to exchange data and return to the original mode of operation.</div></div><div id="Sec14" class="Section4 RenderAsSection4"><h5 class="Heading">Hibernate</h5><div id="Par61" class="Para">When the system is in hibernate mode, an image of the operating mode is saved to external memory and then the computer is turned off. When you turn on the power and reboot, operation reverts to the earlier look: files and documents are arranged as you left them on the desktop.</div><div id="Par62" class="Para">Hibernate mode is deeper than standby mode and thus helps save more power, but the computer takes longer to restart. In addition, hibernate mode includes higher security. This is because this mode not only closes the power supply to the peripherals and hard disk but also cuts off the power supply of the RAM memory chips. This mode is also known as <span class="EmphasisTypeItalic">suspend to disk</span> (STD).</div><div id="Par63" class="Para">As the computer enters hibernate mode, before the power is turned off, all data is stored (written) in external memory (usually a hard disk) to the reference file. On coming out of hibernate mode, the system is restored (read) from the reference file, and data is reloaded into memory. In this way, the system reverts to the previous operating mode. Because hibernate mode needs to save memory data, the recovery (wake-up) time is longer than with standby mode.</div><div id="Par64" class="Para">The advantage of this mode is that no power is consumed, and thus you need not be afraid of power anomalies during sleep. It can also save and restore the user state, but this requires the same space on the hard disk as the physical memory size.</div><div id="Par65" class="Para">Hibernation of a computer system is almost as quiet as regular shutdown; you can completely remove power, and memory data (running) won’t be lost due to a power failure. Compared to standby, hibernation is generally difficult to wake up with an external device; it needs to start the system with a normal boot. However, hibernate mode boots the system without triggering a regular start process: it only needs the hard disk memory mirroring read taken into memory, so it is much faster than a standard boot.</div></div><div id="Sec15" class="Section4 RenderAsSection4"><h5 class="Heading">Sleep</h5><div id="Par66" class="Para">Sleep mode combines all the advantages of standby and hibernation. The system switches to the sleep state; all the data in system memory dumps into the hibernation file on the hard disk, and then all power to the equipment in addition to memory is turned off so data in memory is maintained. Thus, restoring power during sleep is not an exception; you can quickly recover directly from the data in memory. If there are power anomalies and the data in memory is lost during sleep, data can also be recovered from the hard disk, but the speed is a little slower. In any case, this model does not result in data loss.</div><div id="Par67" class="Para">Sleep mode is not always continuously maintained. If the system enters sleep mode for a period of time without being awakened, it may automatically change to hibernate mode and turn off the power supply to the memory to further reduce energy consumption.</div><div id="Par68" class="Para">Achieving these low-power energy-saving features requires both operating system support and hardware support, such as support for ACPI. Only by combining these features can you achieve the energy savings described. When the idle time (also known as non-active time) reaches a specified length or the battery power is low, the operating system can automatically put your computer system in a low-power state, saving energy for the entire system.</div></div></div></div></div><div id="Sec16" class="Section1 RenderAsSection1"><h2 class="Heading">Linux Power-Control Mechanism</h2><div id="Par69" class="Para">Android is based on Linux. Linux has a lot of practical tools for analyzing and reducing power consumption, some of which have been adopted by Android. The following sections describe several types of Linux power control and management, including many aspects of the technology and its components.</div><div id="Sec17" class="Section2 RenderAsSection2"><h3 class="Heading">Tickless Idle</h3><div id="Par70" class="Para">, sometimes called <span class="EmphasisTypeItalic">non-fixed frequency</span> or <span class="EmphasisTypeItalic">no empty circulation</span>, is the technology used in the Android Linux kernel to improve its power-saving ability.</div><div id="Par71" class="Para">The traditional Linux kernel processor uses a periodic timer to record the state of the system, load balance, schedule, and maintain a variety of processor timer events. Early timer frequencies were generally 100 Hz. The new kernel uses 250 Hz or up to 1,000 Hz. However, when the processor is idle, these periodic timed events consume a lot of power. Tickless idle eliminates this periodic timer event in the processor and is also related to the optimization of other timers.</div><div id="Par72" class="Para">After using tickless idle, the Linux kernel is an empty cycle-free kernel. The kernel still records the time, but using a different approach. There is no longer frequent checking to see if there is work to be done. When the kernel knows there is work to be done, it schedules hardware to issue an interrupt request. Tickless idle technology has another indirect benefit in energy efficiency: you can make better use of virtual technology, which means the virtualization software is not interrupted unnecessarily or too often.</div><div id="Par73" class="Para">Tickless idle provides the necessary kernel foundation for excellent power savings. However, it also requires collaboration with the application. If the application does not follow the principle of low-power design, is badly written, or is using the wrong behavior, it may easily consume or waste the power savings created by tickless idle.</div></div><div id="Sec18" class="Section2 RenderAsSection2"><h3 class="Heading">PowerTOP</h3><div id="Par74" class="Para">PowerTOP helps users find applications that consume additional power when the computer is idle. It has a more prominent role for advanced software. Here are PowerTOP’s features:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par75" class="Para">Gives recommendations to help users make better use of the system’s various hardware power-saving features</div></li><li><div id="Par76" class="Para">Identifies culprit software modules that prevent hardware power savings from achieving optimal performance</div></li><li><div id="Par77" class="Para">Helps developers test their applications and achieve optimal behavior</div></li><li><div id="Par78" class="Para">Provides adjustment proposals to access low power</div></li></ul></div>
            </div><div id="Par79" class="Para">A screenshot of PowerTOP running is shown in Figure <span class="InternalRef"><a href="#Fig2">13-2</a></span>.<div class="Figure" id="Fig2"><div class="MediaObject" id="MO3"><img src="A978-1-4842-0100-8_13_Fig2_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig2_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-2.</span><div class="SimplePara">PowerTOP interface example</div></div></div></div>
            </div><div id="Par80" class="Para">Many Linux systems on the Intel Atom platform, such as Ubuntu, support the PowerTOP tool. Figure <span class="InternalRef"><a href="#Fig2">13-2</a></span> shows PowerTOP running in Ubuntu. Android does not support this tool yet (it is not known if Android will support it in the future). However, Intel has recently provided tools on Android with functionality similar to that of PowerTOP, as introduced in the following sections.</div></div></div><div id="Sec19" class="Section1 RenderAsSection1"><h2 class="Heading">Intel Power-Optimization Aids</h2><div id="Par81" class="Para">Intel has introduced some aids to help with low-power design for Android applications. The role of these auxiliary tools is similar to the profiler with regard to performance optimization, VTune, and so on. With these tools, you can do tool-assisted optimization on the application’s power consumption. In other words, the aids offer guidance or counseling. To achieve real optimization, you must rewrite the code in accordance with low-power design principles (described in the following sections).</div><div id="Par82" class="Para">Intel developed the Intel Mobile Development Kit for Android for system or middleware developers to create Android system or middleware software that takes advantage of the latest innovations Intel platforms have to offer. This kit provides access to an x86 (Intel Architecture) based tablet, development tools designed to seamlessly create software for this device, and technical collateral about the OS, tools, system software, middleware, and hardware. You can purchase the kit at <span class="ExternalRef"><a href="https://software.intel.com/en-us/intel-mobile-development-kit-for-android"><span class="RefSource">
                <span class="EmphasisFontCategoryNonProportional">https://software.intel.com/en-us/intel-mobile-development-kit-for-android</span>
              </span></a></span>.</div><div id="Par83" class="Para">You can also use the Intel Graphics Performance Analyzers (GPA): free, low-power auxiliary tools provided by Intel to help Android applications save power. Intel GPA–assisted speed and performance optimization features were introduced in the previous chapter. This section emphasizes its auxiliary functions for power optimization.</div><div id="Par84" class="Para">Indicators related to the machine’s power consumption include CPU frequency, current charging, current discharging, and so on. CPU frequency reflects the operating frequency of the processor in the CPU column. As mentioned in the section “The Basics of Consumption,” the operating frequency directly reflects the dynamic power consumption of the processor: the higher the frequency, the higher the processor power consumption. Therefore, by observing CPU frequency, you can analyze the (dynamic) power consumption of the processor when the application is running.</div><div id="Par85" class="Para">When analyzing the CPU frequency, you can drag and drop the CPU in the CPU Column XX Frequency indicator items to the display window for observation. Figure <span class="InternalRef"><a href="#Fig3">13-3</a></span> shows the CPU frequency during an analysis of a sample app, MoveCircle.<div class="Figure" id="Fig3"><div class="MediaObject" id="MO4"><img src="A978-1-4842-0100-8_13_Fig3_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig3_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-3.</span><div class="SimplePara">Intel GPA CPU frequency analysis</div></div></div></div>
          </div><div id="Par86" class="Para">The vertical axis in Figure <span class="InternalRef"><a href="#Fig3">13-3</a></span> is the operating frequency of the CPU; the unit is megahertz (MHz). In this example, the target machine is a Lenovo K800 Smartphone with an Intel Atom processor, two logical CPUs, and two display windows. As you can see, when the application has a computing task, the CPU increases the frequency to cater to the needs of the calculation; when computing tasks are light, the CPU reduces the operating frequency to save power.</div><div id="Par87" class="Para">The Current Charging and Current Discharging indicators reflect the charge and discharge conditions. Unlike CPU frequencies, these reflect the machine’s overall power consumption. Current Discharging indicates the discharge status; this is a direct reflection of the machine’s power consumption, and it is the direct target you want to observe. However, during the Intel GPA analysis, the target machine is connected to the host via a USB cable, so the host becomes a power supply and is charging the target machine (phone). Thus you should not ignore the Current Charging indicator when analyzing overall machine power consumption.</div><div id="Par88" class="Para">While analyzing overall machine power consumption, you can drag and drop the power bar under the corresponding Current Charging (top graph) and Current Discharging (bottom graph) index entries to the display window to observe them. Figure <span class="InternalRef"><a href="#Fig4">13-4</a></span> shows an analysis of the machine’s charging and discharging using the sample MoveCircle app.<div class="Figure" id="Fig4"><div class="MediaObject" id="MO5"><img src="A978-1-4842-0100-8_13_Fig4a_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig4a_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig4b_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig4b_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-4.</span><div class="SimplePara">Intel GPA machine overall power analysis</div></div></div></div>
          </div><div id="Par89" class="Para">The vertical axis in Figure <span class="InternalRef"><a href="#Fig4">13-4</a></span> is in the current in milliamperes (mA). When the voltage is constant, it is a direct reflection of power consumption. When no application is running, the charge (Current Charging) maintains a natural fluctuation of the state, and the discharge (Current Discharging) stays almost 0 for the low state, as shown in Figure <span class="InternalRef"><a href="#Fig4">13-4(b)</a></span>. When the application is running, due to the increase in the dynamic power consumption of the CPU, the discharge no longer maintains the 0 state. Discharge at the same time lowers the value of the charge; this is visible in Figure <span class="InternalRef"><a href="#Fig4">13-4(a)</a></span>. When the user locks the screen, the screen may go blank and running applications may also be suspended, quickly reducing the CPU’s dynamic power consumption; this brings the discharge almost back to the 0 state, and the charge rises. This process is shown in Figure <span class="InternalRef"><a href="#Fig4">13-4(c)</a></span>.</div><div id="Par90" class="Para">As you can also see in the previous figures, the Intel Atom processor and Android have load-sensing power-management capabilities, and they work together on dynamic power management. When the application is not running or is completing low-power computing tasks, the system perceives this change, and the hardware (processor) control technology jumps in and reduces power consumption. It usually does so by lowering the operating frequency/voltage using EIST.</div></div><div id="Sec20" class="Section1 RenderAsSection1"><h2 class="Heading">Low-Power Considerations in Application Design</h2><div id="Par91" class="Para">Hardware and operating systems provide good technical support for low power consumption by the system, and this can also be accomplished using appropriate management mechanisms and means of control. However, the ultimate low-power target requires the close cooperation of the application. If the application is developed without following the principle of low-power design, the final program may either not use the system’s low-power potential or waste power, cancelling out the power savings from the low-power technology provided by the hardware and operating system. Therefore, this chapter emphasizes the importance of low-power requirements and principles in application design.</div><div id="Par92" class="Para">Low-power design requirements and principles in application development involve many technologies and methodologies. Let’s examine the major principles and recommendations.</div><div id="Sec21" class="Section2 RenderAsSection2"><h3 class="Heading">The Most Basic Principle of Low-Power Optimization</h3><div id="Par93" class="Para">The most basic principle of low-power optimization is to minimize the working hours of the processor and various peripherals. When a peripheral is not required and processor operation is not required, the best way to reduce their power consumption is to turn them off.</div><div id="Par94" class="Para">Because the processor uses a larger proportion of the total power consumption of the system, the processor’s working hours need to be as short as possible; it should spend longer in idle mode or power-down mode. This is a software design key to reducing the mobile system’s power consumption.</div></div><div id="Sec22" class="Section2 RenderAsSection2"><h3 class="Heading">General Recommendations: High Performance = Low Power Consumption</h3><div id="Par95" class="Para">In most cases with fixed voltage, running at peak velocity (high frequency) for a short period of time with a long time in a deep idle state is much more energy efficient than a long run at a medium operating frequency with a mild idle state. Therefore, for the same task, much less electricity is consumed if your app runs to completion in the shortest possible time and then enters an idle state, rather than runs over a longer time to completion before entering a short idle state.</div><div id="Par96" class="Para">A fast algorithm can also reduce power consumption, which follows the recommendation that high performance is equal to low power consumption.</div></div><div id="Sec23" class="Section2 RenderAsSection2"><h3 class="Heading">Use Low-Power Hardware as Much as Possible to Achieve the Task</h3><div id="Par97" class="Para">The same task can be accomplished with different types of hardware, and different hardware has different power-consumption overhead. When your app has the option to choose different hardware to run the same task, you should choose low-power hardware.</div><div id="Par98" class="Para">In general, the energy consumption of the register access is the lowest; and the energy consumption of cache access is lower than the energy consumption of main memory access. Therefore, the program design should try to follow these suggestions:
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par99" class="Para">Use the register as effectively as possible.</div></li><li><div id="Par100" class="Para">Analyze the behavior of the cache to discover the main cache conflict.</div></li><li><div id="Par101" class="Para">Use page-mode access as much as possible in the storage system.</div></li></ul></div>
            </div></div><div id="Sec24" class="Section2 RenderAsSection2"><h3 class="Heading">Polling Is the Enemy of Low-Power Optimization</h3><div id="Par102" class="Para">Programs waiting for state changes or accessing peripheral devices may use polling; this method is sometimes referred to as <span class="EmphasisTypeItalic">rapid rotation</span> or <span class="EmphasisTypeItalic">spinning</span> code. Polling allows the processor to perform a few instructions repeatedly. Power consumption is roughly equal to heavy computing tasks, and its role is just waiting for a status change; but the waiting period cannot allow the processor to enter an idle state, resulting in a lot of wasted power. Therefore, in low-power design, you should try to avoid using polling and instead use alternative methods. For example, you should use interrupts instead of polling access peripherals. In the client/server collaboration model, you should change the client inquiry service to have the server actively push services to the client. For thread synchronization, if you need to query the status change, you should use the operating system event or semaphore.</div><div id="Par103" class="Para">For example, suppose Thread 2 wants to access a resource. The ability to access is determined by the access-control variable <span class="EmphasisFontCategoryNonProportional">canGo</span>. Thread 1 is responsible for on or off access control of variables <span class="EmphasisFontCategoryNonProportional">canGo</span>. If this is achieved by the polling statement, the thread code may be as follows:</div><div id="Par105" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">volatile boolean canGo = false;            // Shared variables</span>
            </div><div id="Par106" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">// The code of thread 1                    // The code of thread 2</span>
            </div><div id="Par107" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">void run()                                 void run()</span>
            </div><div id="Par108" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">{                                          {</span>
            </div><div id="Par109" class="Para ParaTypeProgramcode">    ......          </div><div id="Par110" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">canGo = true;                               while (!canGo);
</span>    // Allow thread 2 to access a resource      // Wait canGo Change to true  
......                              ...... <span class="EmphasisFontCategoryNonProportional">// Access to the resource code</span>
            </div><div id="Par111" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">}                                           }</span>
            </div><div id="Par114" class="Para">In the previous code, the Thread 2 <span class="EmphasisFontCategoryNonProportional">while</span> statement is typical of polling; it consumes a lot of processor time to prevent entry into the idle sleep state. You can change to a Java wait-notify mechanism to achieve the same functions:</div><div id="Par116" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">volatile boolean canGo = false;</span>
            </div><div id="Par117" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">Object sema;                      // The synchronization lock canGo variable</span>
            </div><div id="Par118" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">// The code of thread 1           // The code of thread 2</span>
            </div><div id="Par119" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">void run()                         void run()</span>
            </div><div id="Par120" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">{                                  {</span>
            </div><div id="Par121" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">synchronized(sema){                synchronized(sema){</span>
            </div><div id="Par122" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">canGo = true; // Allow thread 2 to access a resource       while (!canGo)</span>
            </div><div id="Par123" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">sema.notifyAll()                    sema.wait();</span>
            </div><div id="Par124" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">}                                  }</span>
            </div><div id="Par125" class="Para ParaTypeProgramcode">    .....                            ......   <span class="EmphasisFontCategoryNonProportional">// Access to the resource code</span>
            </div><div id="Par126" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">}                                  }</span>
            </div><div id="Par128" class="Para">After being replaced by the wait-notify code, thread 2 has no rapid rotation of the polling statement: each time it checks the <span class="EmphasisFontCategoryNonProportional">canGo</span> variable in a loop, if the conditions are not met, it enters the suspend state and releases the CPU. So, the CPU load is not wasted on the thread. When the CPU has no other tasks, the load soon drops to a low state. When low load to the processor is detected, the system takes measures to reduce power consumption. This could not be done with the rapid rotation of polling mode before the optimization.</div></div><div id="Sec25" class="Section2 RenderAsSection2"><h3 class="Heading">Event-Driven Programming</h3><div id="Par129" class="Para">In addition to implementing the software design methodology, low-power programs should always follow the <span class="EmphasisTypeItalic">event-driven model</span> of program design if possible. Event-driven programming means the program is designed to respond to events: when an event arrives, the application runs to handle the event; when no event arrives or the event is finished, the program gives up the processor and changes to a sleep state. Here the event is referred to as a <span class="EmphasisTypeItalic">generalized event</span>, including user input, network communication events, and process/thread synchronization events.</div><div id="Par130" class="Para">When the event-driven design process is used, processor utilization is particularly high: programs only run when there are real things to deal with, and they free the processor when there is nothing to do. When the processor is in an idle state, the operating system and hardware can detect the idle in a timely manner and initiate the operation to reduce power consumption.</div></div><div id="Sec26" class="Section2 RenderAsSection2"><h3 class="Heading">Reduce Periodic Operations Similar to Polling in Application Programs</h3><div id="Par131" class="Para">Earlier you saw that the polling operation consumes unnecessary energy. Unnecessary programming of periodic triggers or running operations can have an effect similar to polling and consume power unnecessarily.</div><div id="Par132" class="Para">
              <span class="EmphasisTypeItalic">Tickless idle</span>, as discussed earlier, is an operating system kernel improvement that follows this principle; it removes periodic timed operations from the kernel. In addition, Linux applications have many unnecessary periodic triggers or running operations, such as these:
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par133" class="Para">Mouse movement, once per second. This is commonly used in screensavers.</div></li><li><div id="Par134" class="Para">Changes in volume, 10 times per second. This is commonly used in the mixer program.</div></li><li><div id="Par135" class="Para">The next minute, once per second. This clock program is commonly used.</div></li><li><div id="Par136" class="Para">USB reader, 10 times per second. This daemon is commonly used.</div></li><li><div id="Par137" class="Para">Other application data and conditions that change:</div></li><li><div id="Par138" class="Para">More than 10 times per second (web browser)</div></li><li><div id="Par139" class="Para">More than 30 times per second (GPS signal acquisition applications)</div></li><li><div id="Par140" class="Para">More than 200 times per second (the Flash plug-in)</div></li></ul></div>
            </div><div id="Par141" class="Para">These unnecessary triggers and operations cause the system to wake up from an idle state. When ported to Android, such operations should be noted and carefully avoided or improved; otherwise they can easily offset power-consumption savings.</div></div><div id="Sec27" class="Section2 RenderAsSection2"><h3 class="Heading">Low-Power Recommendations for Data Acquisition and Communications</h3><div id="Par142" class="Para">When designing communication modules, try to improve the communication rate. When the communication rate is increased, it means communication time is shortened and fewer high-power communications, reducing total power consumption.</div><div id="Par143" class="Para">Similarly, when using Wi-Fi communication, you should use burst mode to transmit data, which can shorten the communication time (especially when sending data). It is easy for Wi-Fi devices to enter an idle state as soon as possible.</div></div><div id="Sec28" class="Section2 RenderAsSection2"><h3 class="Heading">Establishing a Power-Aware Program</h3><div id="Par144" class="Para">Power for Android devices often toggles between being connected to an external power supply and using battery power. The power requirements of the software for both power states are completely different: the former is power-insensitive but requires that priority be put on performance most of time; the latter is power-consumption-sensitive and therefore needs to strike a balance between performance and power consumption. Thus the application should detect the type of power supply and make adjustments to adapt to power-related changes.</div><div id="Par145" class="Para">In addition, some power-management factors may affect software behavior, such as when the device’s battery is below a certain threshold and the device enters the closed state and automatic sleep, and so on. Application design should take into account environmental changes brought about by these power-management events, pay attention to the possible impact of these factors, and respond appropriately. For example, ongoing processing of time-consuming operations (such as lengthy floating-point operations, the query circulating system, and complex graphics reproduction) can be interrupted or suspended by power-management events. One of the countermeasures is to save the scene and make sure the environment is allowed time to recover from the interrupt status.</div><div id="Par146" class="Para">In addition, you can develop a kind of defensive programming for power, such as advance consideration or prediction of what kind of task or application the user will start (for example, playing a movie); or determining in advance whether there is enough battery power to complete the task, and if not, alerting the user at the start of the task.</div></div></div><div id="Sec29" class="Section1 RenderAsSection1"><h2 class="Heading">Case Study 1: Intel GPA Assisted Power Optimization for an Android Application</h2><div id="Par147" class="Para">Following is a case study to demonstrate a comprehensive approach that uses the Intel GPA power-analysis tools to rewrite and optimize an application that has high power consumption, in accordance with low-power design principles.</div><div id="Sec30" class="Section2 RenderAsSection2"><h3 class="Heading">Original Application and Intel GPA Power Analysis</h3><div id="Par148" class="Para">The example application runs for a specified period of time (20 seconds). This application, without low-power optimized code, is called <span class="EmphasisFontCategoryNonProportional">PollLast</span>. The application design calls for it to get the current time through the static function <span class="EmphasisFontCategoryNonProportional">currentTimeMillis</span> of the Java <span class="EmphasisFontCategoryNonProportional">System</span> class; the current time plus the duration of the runtime specified in the program is equal to the end of the program run. The program then gets the current time in the looping function <span class="EmphasisFontCategoryNonProportional">currentTimeMillis</span> and compares it with the program end time. If the current time exceeds the program end time, the program ends the loop and finishes the program. Because the entire task takes a long time to process, you run the program as a worker thread so it does not affect the response of the main interface. The main interface controls the start of the task.</div><div id="Par149" class="Para">The application’s operation interface is shown in Figure <span class="InternalRef"><a href="#Fig5">13-5</a></span>.<div class="Figure" id="Fig5"><div class="MediaObject" id="MO6"><img src="A978-1-4842-0100-8_13_Fig5_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig5_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-5.</span><div class="SimplePara">Separate <span class="EmphasisFontCategoryNonProportional">PollLast</span> applications running in the interface</div></div></div></div>
            </div><div id="Par150" class="Para">The main steps to create the application are as follows:<div class="OrderedList"><div class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"><div id="Par151" class="Para">Create a new project called <span class="EmphasisFontCategoryNonProportional">PollLast</span>. Set the proposed project property to use the default value, and select the Build SDK version which supports the x86 API.</div></div><div class="ClearBoth"> </div></div><div class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"><div id="Par152" class="Para">Edit the main layout file, and place two <span class="EmphasisFontCategoryNonProportional">Button</span>s and two <span class="EmphasisFontCategoryNonProportional">TextView</span>s on the layout; one is used to display the operating status of the task thread, as shown in Figure <span class="InternalRef"><a href="#Fig6">13-6</a></span>.</div></div><div class="ClearBoth"> </div></div></div>
            </div><div id="Par153" class="Para">  <div class="Figure" id="Fig6"><div class="MediaObject" id="MO7"><img src="A978-1-4842-0100-8_13_Fig6_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig6_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-6.</span><div class="SimplePara">The main layout of the  application</div></div></div></div>
              <div class="OrderedList"><div class="ListItem"><span class="ItemNumber">3.</span><div class="ItemContent"><div id="Par154" class="Para">Create a new task thread class <span class="EmphasisFontCategoryNonProportional">MyTaskThread</span>, which will run a specified time. Edit the source code file <span class="EmphasisFontCategoryNonProportional">MyTaskThread.java</span> as follows:</div></div><div class="ClearBoth"> </div></div></div>
            </div><div id="Par156" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">1. package com.example.polllast;</span>
            </div><div id="Par157" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">2. import android.os.Handler;</span>
            </div><div id="Par158" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">3. import android.os.Message;</span>
            </div><div id="Par160" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">4. public class MyTaskThread extends Thread {</span>
            </div><div id="Par161" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">5.  private Handler mainHandler;</span>
            </div><div id="Par162" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">6.  public static final int MSG_FINISHED = 1;</span>
            </div><div id="Par163" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">7.  public static final int lasthour = 0;    // The number of hours the program is running</span>
            </div><div id="Par164" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">8.  public static final int lastmin = 0;     // The number of minutes of the program to run</span>
            </div><div id="Par165" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">9.  public static final int lastsec = 20;    // The number of seconds the program is running</span>
            </div><div id="Par167" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">10. @Override</span>
            </div><div id="Par168" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">11. public void run()</span>
            </div><div id="Par169" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">12. {</span>
            </div><div id="Par170" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">13.     long start_time = System.currentTimeMillis();</span>
            </div><div id="Par171" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">14.     long millisecduration = ((lasthour * 60 + lastmin) * 60 + lastsec)*1000;</span>
            </div><div id="Par172" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">15.         long endtime = start_time + millisecduration;</span>
            </div><div id="Par173" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">16.         long now;</span>
            </div><div id="Par174" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">17.         do {</span>
            </div><div id="Par175" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">18.             now = System.currentTimeMillis();      // Polling</span>
            </div><div id="Par176" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">19.         }    while (now &lt; endtime);</span>
            </div><div id="Par177" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">20.         Message msg = new Message();</span>
            </div><div id="Par178" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">21.         msg.what = MSG_FINISHED;</span>
            </div><div id="Par179" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">22.         mainHandler.sendMessage(msg);</span>
            </div><div id="Par180" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">23.     }</span>
            </div><div id="Par182" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">24.     public MyTaskThread(Handler mh)</span>
            </div><div id="Par183" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">25.     {</span>
            </div><div id="Par184" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">26.         super();</span>
            </div><div id="Par185" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">27.         mainHandler = mh;</span>
            </div><div id="Par186" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">28.     }</span>
            </div><div id="Par187" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">29. }</span>
            </div><div id="Par189" class="Para">The gray background marks the major code segments where changes are made. In lines 7–9, you assign three constants <span class="EmphasisFontCategoryNonProportional">lasthour</span>, <span class="EmphasisFontCategoryNonProportional">lastmin</span>, and <span class="EmphasisFontCategoryNonProportional">lastsec</span>, respectively, as the task’s running time in hours, minutes, and seconds. The code in lines 13 and 14 is a core part of the task. In lines 13–15, you set the task start time, duration, and end time, in milliseconds. Line 16 defines the current-time variable <span class="EmphasisFontCategoryNonProportional">now</span>. In lines 17–19, you use a loop to poll and compare time. Each cycle first gets the current time and then compares it with the end time; if the current time is greater than the end time, the loop is ended.</div><div id="Par190" class="Para">This is typical polling code. The loop body is only a statement to query the current time, so the loop is very fast and consumes lots of processor computing resources.
<div class="OrderedList"><div class="ListItem"><span class="ItemNumber">4.</span><div class="ItemContent"><div id="Par191" class="Para">Edit the main activity class source code file <span class="EmphasisFontCategoryNonProportional">MainActivity.java</span>, and let it control running the task thread. The code sections are almost the same as the <span class="EmphasisFontCategoryNonProportional">MainActivity</span> example’s <span class="EmphasisFontCategoryNonProportional">SerialPi</span> class code (see <span class="ExternalRef"><a href="A978-1-4842-0100-8_8_Chapter.html"><span class="RefSource">Chapter 8</span></a></span>).</div></div><div class="ClearBoth"> </div></div><div class="ListItem"><span class="ItemNumber">5.</span><div class="ItemContent"><div id="Par192" class="Para">Modify the project’s <span class="EmphasisFontCategoryNonProportional">AndroidManifest.xml</span> file to meet the Intel GPA monitoring requirements.</div></div><div class="ClearBoth"> </div></div></div>
            </div><div id="Par193" class="Para">Now you can deploy the application to the target machine. This example uses the Lenovo K800 mobile phone as a test target.</div><div id="Par194" class="Para">Figure <span class="InternalRef"><a href="#Fig7">13-7</a></span> and Figure <span class="InternalRef"><a href="#Fig8">13-8</a></span> show the analysis using Intel GPA. This example analyzes the main monitor CPU frequency (the CPU XX Frequency indicator) and the charge or discharge (Current Charging and Current Discharging indicators). You click the Start Run button to start running the task and recording the Intel GPA monitoring information. <div class="Figure" id="Fig7"><div class="MediaObject" id="MO8"><img src="A978-1-4842-0100-8_13_Fig7a_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig7a_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig7b_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig7b_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig7c_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig7c_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-7.</span><div class="SimplePara">
                      <span class="EmphasisFontCategoryNonProportional">PollLast</span> Intel GPA CPU frequency analysis</div></div></div></div>
              <div class="Figure" id="Fig8"><div class="MediaObject" id="MO9"><img src="A978-1-4842-0100-8_13_Fig8a_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig8a_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig8b_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig8b_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig8c_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig8c_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-8.</span><div class="SimplePara">
                      <span class="EmphasisFontCategoryNonProportional">PollLast</span> Intel GPA charge/discharge analysis</div></div></div></div>
            </div><div id="Par195" class="Para">From the CPU frequency chart in Figure <span class="InternalRef"><a href="#Fig7">13-7</a></span>, you can see that CPU frequency jumps from 600 MHz up to 1.6 GHz after starting the task and drops back to 600 MHz after running the task. Of course, both logical CPU frequencies do not jump up to 1.6 GHz when the task is running: they have a complementary relationship. When the task is running, only one CPU frequency jumps to the highest values. The main reason for this complementary effect is that this example task has only one worker thread.</div><div id="Par196" class="Para">The machine’s charge is shown in Figure <span class="InternalRef"><a href="#Fig8">13-8</a></span> in a map view of discharge conditions. The discharge maintained a level below 400 mA before starting the task, as shown in Figure <span class="InternalRef"><a href="#Fig8">13-8(a)</a></span>. After starting the task, the discharge jumped to levels above 550 mA. After running the task, discharge level returned to 400 mA or less. The phone was fully charged before running, so the entire example process was always charged in a low state of approximately 0. Discharge reflects the charge level of the machine under the same total power consumption. Running the task led to a dramatic increase in power consumption.</div></div><div id="Sec31" class="Section2 RenderAsSection2"><h3 class="Heading">Optimized Applications and an Intel GPA Power Analysis</h3><div id="Par197" class="Para">Through the code analysis of the <span class="EmphasisFontCategoryNonProportional">PollLast</span> application, you know that using a polling statement causes machine power consumption to rise, especially in <span class="EmphasisFontCategoryNonProportional">MyTaskThread.java</span> lines 17–19. You need to rewrite this segment by applying the low-power application design principles as previously described and change the polling code. You can create an optimized solution that lets the thread sleep the specified time instead of polling. This application is an improved version based on <span class="EmphasisFontCategoryNonProportional">PollLast</span>, with these changes:<div class="OrderedList"><div class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"><div id="Par198" class="Para">Create a new project <span class="EmphasisFontCategoryNonProportional">SleepLast</span>. Set the proposed project property to use the default value, and select the Build SDK which supports the x86 API.</div></div><div class="ClearBoth"> </div></div><div class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"><div id="Par199" class="Para">Copy the <span class="EmphasisFontCategoryNonProportional">PollLast</span> main layout file to the project, and replace the original layout of the project file.</div></div><div class="ClearBoth"> </div></div><div class="ListItem"><span class="ItemNumber">3.</span><div class="ItemContent"><div id="Par200" class="Para">Copy the original application <span class="EmphasisFontCategoryNonProportional">MyTaskThread.java</span> to this project, and modify its contents as follows:</div></div><div class="ClearBoth"> </div></div></div>
            </div><div id="Par202" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">1. package com.example.sleeplast;</span>
            </div><div id="Par203" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">2. import android.os.Handler;</span>
            </div><div id="Par204" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">3. import android.os.Message;</span>
            </div><div id="Par206" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">4. public class MyTaskThread extends Thread {</span>
            </div><div id="Par207" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">5.     private Handler mainHandler;</span>
            </div><div id="Par208" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">6.     public static final int MSG_FINISHED = 1;</span>
            </div><div id="Par209" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">7.     public static final int lasthour = 0;        // The number of hours run</span>
            </div><div id="Par210" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">8.     public static final int lastmin = 0;         // The number of minutes run</span>
            </div><div id="Par211" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">9.     public static final int lastsec = 20;        // The number of seconds to run</span>
            </div><div id="Par213" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">10.     @Override</span>
            </div><div id="Par214" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">11.     public void run()</span>
            </div><div id="Par215" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">12.     {</span>
            </div><div id="Par216" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">13.         long millisecduration = ((lasthour * 60 + lastmin) * 60 + lastsec)*1000;</span>
            </div><div id="Par217" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">14.         try {</span>
            </div><div id="Par218" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">15.             Thread.sleep(millisecduration);</span>
            </div><div id="Par219" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">16.         } catch (InterruptedException e) {</span>
            </div><div id="Par220" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">17.             e.printStackTrace();</span>
            </div><div id="Par221" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">18.         }</span>
            </div><div id="Par222" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">19.         Message msg = new Message();</span>
            </div><div id="Par223" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">20.         msg.what = MSG_FINISHED;</span>
            </div><div id="Par224" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">21.         mainHandler.sendMessage(msg);</span>
            </div><div id="Par225" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">22.     }</span>
            </div><div id="Par227" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">23.     public MyTaskThread(Handler mh)</span>
            </div><div id="Par228" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">24.     {</span>
            </div><div id="Par229" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">25.         super();</span>
            </div><div id="Par230" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">26.         mainHandler = mh;</span>
            </div><div id="Par231" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">27.     }</span>
            </div><div id="Par232" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">28. }</span>
            </div><div id="Par234" class="Para">The first line of code is the declaration of the application package.</div><div id="Par235" class="Para">The main changes are from lines 13–18. Here you use the static function <span class="EmphasisFontCategoryNonProportional">sleep</span> of the <span class="EmphasisFontCategoryNonProportional">Thread</span> class to specify how long the thread should sleep. The application calculates the sleep time in milliseconds in line 13. Because <span class="EmphasisFontCategoryNonProportional">sleep</span> may throw an <span class="EmphasisFontCategoryNonProportional">InterruptedException</span> exception, you put the function into a  statement block.<div class="OrderedList"><div class="ListItem"><span class="ItemNumber">4.</span><div class="ItemContent"><div id="Par236" class="Para">Copy the <span class="EmphasisFontCategoryNonProportional">MainActivity.java</span> from the original application to cover the same documents. Change its package-declaration line to</div></div><div class="ClearBoth"> </div></div></div>
            </div><div id="Par238" class="Para ParaTypeProgramcode">
              <span class="EmphasisFontCategoryNonProportional">package com.example.sleeplast;</span>
            </div><div class="Para">
              <div class="OrderedList"><div class="ListItem"><span class="ItemNumber">5.</span><div class="ItemContent"><div id="Par240" class="Para">Modify the project’s <span class="EmphasisFontCategoryNonProportional">AndroidManifest.xml</span> file to match the Intel GPA monitoring requirements.</div></div><div class="ClearBoth"> </div></div></div>
            </div><div id="Par241" class="Para">Now you can deploy the application to the target machine. Again, this example uses a Lenovo K800.</div><div id="Par242" class="Para">In the real world, you only need to modify the source code of the original application to achieve the optimization for low-power consumption—you don’t need to create a separate application. For example, in this case, you would only need to do step 3. This example creates an optimized version of the application to highlight the differences.</div><div id="Par243" class="Para">Following the same procedure as with the original application, you can use Intel GPA to analyze the optimized application. The results are shown in Figure <span class="InternalRef"><a href="#Fig9">13-9</a></span> and Figure <span class="InternalRef"><a href="#Fig10">13-10</a></span>.<div class="Figure" id="Fig9"><div class="MediaObject" id="MO10"><img src="A978-1-4842-0100-8_13_Fig9a_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig9a_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig9b_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig9b_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig9c_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig9c_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-9.</span><div class="SimplePara">Intel GPA CPU frequency analysis of the  application</div></div></div></div>
              <div class="Figure" id="Fig10"><div class="MediaObject" id="MO11"><img src="A978-1-4842-0100-8_13_Fig10a_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig10a_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig10b_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig10b_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig10c_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig10c_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-10.</span><div class="SimplePara">Intel GPA charge/discharge analysis of</div></div></div></div>
            </div><div id="Par244" class="Para">In Figure <span class="InternalRef"><a href="#Fig9">13-9</a></span>, compare the graph when the task has not yet started (Figure <span class="InternalRef"><a href="#Fig9">13-9(a)</a></span>) and graph when the task is complete Figure <span class="InternalRef"><a href="#Fig9">13-9(c)</a></span>): the processor frequency does not change (Figure <span class="InternalRef"><a href="#Fig9">13-9(b)</a></span>) when the task runs. Essentially, all three states have the same frequency and remain at a low level of 600 MHz. This reflects the fact that the processor’s dynamic power consumption before, during, and after the process did not change significantly and maintained low load levels.</div><div id="Par245" class="Para">Figure <span class="InternalRef"><a href="#Fig10">13-10</a></span> reflects overall machine power consumption, which is also consistent. Before starting the task (Figure <span class="InternalRef"><a href="#Fig10">13-10(a)</a></span>), during the running of the application (Figure <span class="InternalRef"><a href="#Fig10">13-10(b)</a></span>), and at the end (Figure <span class="InternalRef"><a href="#Fig10">13-10(c)</a></span>), discharge maintained a low level of approximately 0. The graph representing charging did not change significantly before, during, or after the application ran. Compared with <span class="EmphasisFontCategoryNonProportional">PollLast</span>, which caused significant overall power consumption, the optimized <span class="EmphasisFontCategoryNonProportional">SleepLast</span> application achieves an optimized power-saving result.</div></div></div><div id="Sec32" class="Section1 RenderAsSection1"><h2 class="Heading">Case Study 2: Timer Optimization and Intel GPA Power Analysis</h2><div id="Par246" class="Para">This section introduces another power-optimization solution: the timer method. You use Java’s <span class="EmphasisFontCategoryNonProportional">Timer</span> and <span class="EmphasisFontCategoryNonProportional">TimerTask</span> to implement a timer. The timer measure the specified time and notifies the task that it should end when a specified time has passed.</div><div id="Par247" class="Para">Follow these steps to create the application:
<div class="OrderedList"><div class="ListItem"><span class="ItemNumber">1.</span><div class="ItemContent"><div id="Par248" class="Para">Create a new project called <span class="EmphasisFontCategoryNonProportional">TimerLast</span>. Set the proposed project property to use the default value, and select the Build SDK version that supports the x86 API.</div></div><div class="ClearBoth"> </div></div><div class="ListItem"><span class="ItemNumber">2.</span><div class="ItemContent"><div id="Par249" class="Para">Copy the main layout file from <span class="EmphasisFontCategoryNonProportional">PollLast</span> to this project, and replace the layout file.</div></div><div class="ClearBoth"> </div></div><div class="ListItem"><span class="ItemNumber">3.</span><div class="ItemContent"><div id="Par250" class="Para">Copy <span class="EmphasisFontCategoryNonProportional">MainActivity.java</span> from <span class="EmphasisFontCategoryNonProportional">PollLast</span> to this project, and modify its contents as follows:</div></div><div class="ClearBoth"> </div></div></div>
          </div><div id="Par252" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">1.  package com.example.timerlast;</span>
          </div><div id="Par253" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">2.  import android.os.Bundle;</span>
          </div><div id="Par254" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">3.  import android.app.Activity;</span>
          </div><div id="Par255" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">4.  import android.view.Menu;</span>
          </div><div id="Par256" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">5.  import android.widget.Button;</span>
          </div><div id="Par257" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">6.  import android.view.View;</span>
          </div><div id="Par258" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">7.  import android.view.View.OnClickListener;</span>
          </div><div id="Par259" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">8.  import android.os.Process;</span>
          </div><div id="Par260" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">9.  import android.widget.TextView;</span>
          </div><div id="Par261" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">10. import android.os.Handler;</span>
          </div><div id="Par262" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">11. import android.os.Message;</span>
          </div><div id="Par263" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">12. import java.util.Timer;</span>
          </div><div id="Par264" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">13.</span>
          </div><div id="Par265" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">14. public class MainActivity extends Activity {</span>
          </div><div id="Par266" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">15.     private TextView tv_TaskStatus;</span>
          </div><div id="Par267" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">16.     private Button btn_ExitApp;</span>
          </div><div id="Par268" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">17.     private Handler mHandler;</span>
          </div><div id="Par269" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">18.     private Timer timer =null;            // Timer</span>
          </div><div id="Par270" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">19.</span>
          </div><div id="Par271" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">20.     @Override</span>
          </div><div id="Par272" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">21.     public void onCreate(Bundle savedInstanceState) {</span>
          </div><div id="Par273" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">......</span>
          </div><div id="Par274" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">35.         final Button btn_StartTask = (Button) findViewById(R.id.startTask);</span>
          </div><div id="Par275" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">36.         btn_StartTask.setOnClickListener(new /*View.*/OnClickListener(){</span>
          </div><div id="Par276" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">37.             public void onClick(View v) {</span>
          </div><div id="Par277" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">38.                 btn_StartTask.setEnabled(false);</span>
          </div><div id="Par278" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">39.                 btn_ExitApp.setEnabled(false);</span>
          </div><div id="Par279" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">40.                 tv_TaskStatus.setText("Task operation...");</span>
          </div><div id="Par280" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">41.                  startTask();</span>
          </div><div id="Par281" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">42.              }</span>
          </div><div id="Par282" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">43.         });</span>
          </div><div id="Par283" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">......</span>
          </div><div id="Par284" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">58.     }</span>
          </div><div id="Par285" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">......</span>
          </div><div id="Par286" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">66.     private void startTask() {</span>
          </div><div id="Par287" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">67.            long millisecduration =</span>
          </div><div id="Par288" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">68.             ((MyTaskTimer.lasthour * 60 + MyTaskTimer.lastmin) * 60 + MyTaskTimer.lastsec)*1000;</span>
          </div><div id="Par289" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">69.         timer = new Timer();              // Creating Timer</span>
          </div><div id="Par290" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">70.         timer.schedule(new MyTaskTimer(mHandler), millisecduration);                // Set the timer</span>
          </div><div id="Par291" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">71.     }</span>
          </div><div id="Par292" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">......</span>
          </div><div id="Par293" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">79. }</span>
          </div><div id="Par295" class="Para">Lines 35–43 are the response code when the Start Run button is clicked. The key code line is line 41, which calls the custom function <span class="EmphasisFontCategoryNonProportional">startTask</span>. Lines 66–71 implement this function code. The program first calculates the total number of milliseconds for the timing. In line 69, the timer is created. Line 70 sets the timer and calls back the <span class="EmphasisFontCategoryNonProportional">MyTaskTimer</span> object when timing ends.
<div class="OrderedList"><div class="ListItem"><span class="ItemNumber">4.</span><div class="ItemContent"><div id="Par296" class="Para">Create a new  class, and let it inherit from the <span class="EmphasisFontCategoryNonProportional">TimerTask</span> class. It is responsible for notifying the activity interface that the task has been completed. Edit the source code file <span class="EmphasisFontCategoryNonProportional">MyTaskTimer.java</span> as follows:</div></div><div class="ClearBoth"> </div></div></div>
          </div><div id="Par298" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">1. package com.example.timerlast;</span>
          </div><div id="Par299" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">2. import java.util.TimerTask;      // TimerTask classes using Java</span>
          </div><div id="Par300" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">3. import android.os.Handler;</span>
          </div><div id="Par301" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">4. import android.os.Message;</span>
          </div><div id="Par302" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">5.</span>
          </div><div id="Par303" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">6. public class MyTaskTimer extends TimerTask {</span>
          </div><div id="Par304" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">7.     private Handler mainHandler;</span>
          </div><div id="Par305" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">8.     public static final int MSG_FINISHED = 1;</span>
          </div><div id="Par306" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">9.     public static final int lasthour = 0;   // The task of operating hours</span>
          </div><div id="Par307" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">10.     public static final int lastmin = 0;   // The task of operating minutes</span>
          </div><div id="Par308" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">11.     public static final int lastsec = 20;  // The task of operating seconds</span>
          </div><div id="Par309" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">12.</span>
          </div><div id="Par310" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">13.     public MyTaskTimer(Handler mh)</span>
          </div><div id="Par311" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">14.     {</span>
          </div><div id="Par312" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">15.         super();</span>
          </div><div id="Par313" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">16.         mainHandler = mh;</span>
          </div><div id="Par314" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">17.     }</span>
          </div><div id="Par315" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">18.</span>
          </div><div id="Par316" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">19.     @Override</span>
          </div><div id="Par317" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">20.     public void run(){</span>
          </div><div id="Par318" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">21.         Message msg = new Message();</span>
          </div><div id="Par319" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">22.         msg.what = MSG_FINISHED;         // Defined message types</span>
          </div><div id="Par320" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">23.         mainHandler.sendMessage(msg);    // Send a message</span>
          </div><div id="Par321" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">24.     }</span>
          </div><div id="Par322" class="Para ParaTypeProgramcode">
            <span class="EmphasisFontCategoryNonProportional">25. }</span>
          </div><div id="Par324" class="Para">According to the Java timer framework, when the timer expires, the program callback function of <span class="EmphasisFontCategoryNonProportional">TimerTask</span> runs. The previous code lets the <span class="EmphasisFontCategoryNonProportional">MyTaskTimer</span> class inherit from <span class="EmphasisFontCategoryNonProportional">TimerTask</span> and allows the code for the self-timing timer to expire in the <span class="EmphasisFontCategoryNonProportional">run</span> function. In this case, lines 19–24 hold the callback code that indicates timing is complete and sends a “finished” message to the main interface. The main interface responds to this message in its own handler and displays a message that the task is ended.</div><div id="Par325" class="Para">Now you can deploy the application to the target machine. As before this example uses a Lenovo K800 smartphone with an Intel Atom processor.</div><div id="Par326" class="Para">Following the same procedure as previously, you can use Intel GPA to analyze the optimized application, record the GPA monitoring information, and analyze the results, as shown in Figure <span class="InternalRef"><a href="#Fig11">13-11</a></span> and Figure <span class="InternalRef"><a href="#Fig12">13-12</a></span>.<div class="Figure" id="Fig11"><div class="MediaObject" id="MO12"><img src="A978-1-4842-0100-8_13_Fig11a_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig11a_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig11b_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig11b_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig11c_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig11c_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-11.</span><div class="SimplePara">Intel GPA CPU frequency analysis of</div></div></div></div>
            <div class="Figure" id="Fig12"><div class="MediaObject" id="MO13"><img src="A978-1-4842-0100-8_13_Fig12a_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig12a_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig12b_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig12b_HTML.jpg"/><img src="A978-1-4842-0100-8_13_Fig12c_HTML.jpg" alt="A978-1-4842-0100-8_13_Fig12c_HTML.jpg"/></div><div class="Caption" xml:lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 13-12.</span><div class="SimplePara">Intel GPA charge/discharge analysis of</div></div></div></div>
          </div><div id="Par327" class="Para">The frequency graph shown in Figure <span class="InternalRef"><a href="#Fig11">13-11</a></span> is similar to the <span class="EmphasisFontCategoryNonProportional">SleepLast</span> graph from Figure <span class="InternalRef"><a href="#Fig9">13-9</a></span>. The processor frequency does not change in Figure <span class="InternalRef"><a href="#Fig11">13-11(b)</a></span> after running the task and has essentially the same frequency as before the task started (Figure <span class="InternalRef"><a href="#Fig11">13-11(a)</a></span>) and after it ended (Figure <span class="InternalRef"><a href="#Fig11">13-11(c)</a></span>). It stayed in the low 600 MHz range. The only difference is a rise in occasional glitches at the end of the task (Figure <span class="InternalRef"><a href="#Fig11">13-11(c)</a></span>). The processor’s dynamic power consumption did not change significantly before, during, and after the process: it maintained low load levels.</div><div id="Par328" class="Para">Figure <span class="InternalRef"><a href="#Fig12">13-12</a></span> shows that overall machine power consumption is consistent with Figure <span class="InternalRef"><a href="#Fig11">13-11</a></span>. Of course, the <span class="EmphasisFontCategoryNonProportional">TimerLast</span> graph is not as pretty as the display in Figure <span class="InternalRef"><a href="#Fig10">13-10</a></span>, which shows the performance of <span class="EmphasisFontCategoryNonProportional">SleepLast</span>—discharge graphs always have some glitches. However, the indicator did not change significantly before the task, while the task ran, and after task completion. This proves that running the task did not cause the extra power consumption. Compared with <span class="EmphasisFontCategoryNonProportional">PollLast</span>, which caused significant overall power consumption, the optimized <span class="EmphasisFontCategoryNonProportional">TimerLast</span> application achieved an optimized power-saving result.</div></div><div id="Sec33" class="Section1 RenderAsSection1"><h2 class="Heading">Book Summary</h2><div id="Par329" class="Para">In this book, you learned how to develop and optimize Android applications on Intel Atom platforms, as well as how to develop power-efficient applications. Here is a summary of the key concepts:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par330" class="Para">Most Android applications written in Java can execute on the Intel Atom platform directly. NDK applications need to recompile native code. If assembly code is included in the application, this portion of the code must be rewritten.</div></li><li><div id="Par331" class="Para">Make full use of Intel Architecture features to improve your Android application performance.</div></li><li><div id="Par332" class="Para">Add platform-specific compile switches to make the GCC build code more effective.</div></li><li><div id="Par333" class="Para">Intel provides various useful tools to help Android developers. Many of them focus on improving performance and can help you optimize your applications.</div></li></ul></div>
          </div><div id="Par334" class="Para">The common methods of creating Android apps are as follows:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div id="Par335" class="Para">Java compiled using the Android SDK APIs, to run in the Dalvik VM. Google is releasing a new Android Runtime (ART) for the new Android L OS at the end of 2014.</div></li><li><div id="Par336" class="Para">Using the latest SDK, testing goes faster if you speed up your Android emulation software with Intel HAXM.</div></li><li><div id="Par337" class="Para">Created in or ported to NDK. This is the preferred method if you have the C++ code. Native C++ code is compiled into a binary before execution and doesn’t require interpretation into machine language.</div></li></ul></div>
          </div><div id="Par338" class="Para">If you don’t have an Android development environment (IDE), the new tool suite Intel Integrated Native Developer Experience (INDE) loads a selected Android IDE and also downloads and installs multiple Intel tools to help you make, compile, troubleshoot, and publish Android applications. Go to <span class="ExternalRef"><a href="https://software.intel.com/en-us/android"><span class="RefSource">
                <span class="EmphasisFontCategoryNonProportional">https://software.intel.com/en-us/android</span>
              </span></a></span> to download and use those tools. You can also visit this book’s Apress web page to keep up with updates and any posted errata: <span class="ExternalRef"><a href="http://www.apress.com/9781484201015"><span class="RefSource">
                <span class="EmphasisFontCategoryNonProportional">www.apress.com/9781484201015</span>
              </span></a></span>.
</div></div></div></body></html>
